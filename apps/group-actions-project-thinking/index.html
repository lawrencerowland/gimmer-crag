<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Group Actions for Project Thinking: Symmetry, Orbits, and Toggle Dynamics</title>
  <link rel="stylesheet" href="../../common.css">
  <style>
    :root{
      --fg:#222;
      --muted:#555;
      --bg:#ffffff;
      --panel:#f6f7f9;
      --border:#d8dde3;
      --accent:#2d6cdf;
      --good:#1a7f37;
      --warn:#b54708;
      --bad:#b42318;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{
      font-family: var(--sans);
      color: var(--fg);
      background: var(--bg);
      margin: 18px;
      line-height: 1.55;
      max-width: 1100px;
    }
    h1{font-size: 1.9rem; margin: 0 0 0.4rem 0;}
    h2{font-size: 1.35rem; margin-top: 1.8rem;}
    h3{font-size: 1.05rem; margin-top: 1.3rem;}
    p{margin: 0.6rem 0;}
    .small{font-size: 0.95rem; color: var(--muted);}
    .panel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 14px;
      margin: 12px 0;
    }
    .grid{
      display: grid;
      gap: 14px;
      grid-template-columns: 1fr 1fr;
    }
    @media (max-width: 920px){
      .grid{grid-template-columns: 1fr;}
    }

    .pill{
      display: inline-block;
      font-family: var(--mono);
      background: #eef2ff;
      border: 1px solid #dbe3ff;
      color:#1d2b6b;
      border-radius: 999px;
      padding: 2px 10px;
      font-size: 0.92rem;
      margin: 0 4px 4px 0;
      white-space: nowrap;
    }
    .kbox{
      font-family: var(--mono);
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      overflow-x: auto;
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items: center;
      margin: 8px 0;
    }
    button, select, input[type="text"]{
      font: inherit;
      padding: 7px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: white;
    }
    button{
      cursor: pointer;
      background: var(--accent);
      color: white;
      border: 1px solid #1f55c9;
    }
    button.secondary{
      background: #ffffff;
      color: var(--fg);
      border: 1px solid var(--border);
    }
    button.danger{
      background: var(--bad);
      border: 1px solid #8a1b14;
    }
    button:disabled{
      opacity:0.55;
      cursor: not-allowed;
    }

    table{
      border-collapse: collapse;
      width: 100%;
    }
    th, td{
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
      font-size: 0.95rem;
    }
    th{
      background: #fafbfc;
    }
    .ok{color: var(--good); font-weight: 600;}
    .no{color: var(--bad); font-weight: 600;}
    .warn{color: var(--warn); font-weight: 600;}
    .muted{color: var(--muted);}
    details > summary{
      cursor:pointer;
      user-select: none;
      margin: 6px 0;
      font-weight: 600;
    }
    .task{
      display:flex;
      gap:10px;
      align-items: flex-start;
      padding: 10px 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      margin: 8px 0;
    }
    .task .meta{
      flex: 1;
    }
    .task .title{
      font-weight: 700;
      margin-bottom: 2px;
    }
    .badge{
      font-size: 0.82rem;
      border-radius: 7px;
      padding: 2px 7px;
      border: 1px solid var(--border);
      background: #fff;
      margin-left: 6px;
      color: var(--muted);
      display: inline-block;
    }
    .badge.done{background:#ecfdf3; border-color:#b7ebc6; color:#0b6623;}
    .badge.blocked{background:#fff5f5; border-color:#ffd0d0; color:#8a1b14;}
    .badge.available{background:#eff6ff; border-color:#cfe2ff; color:#1f4fbf;}

    .mono{font-family: var(--mono);}
    .hr{
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }
    .callout{
      border-left: 4px solid var(--accent);
      padding: 8px 12px;
      background: #f2f6ff;
      border-radius: 8px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <p><a href="../../index.html">Back to app index</a></p>
  <h1>Group Actions for Project Thinking</h1>
  <p class="small">
    A more ambitious lens: treat “project moves” as algebraic operations acting on a well-chosen state space, then use orbits, stabilisers, quotients, and Schreier graphs to reason about equivalence of plans, not merely to permute a toy task list.
    The most project-native place where honest-to-God group actions show up is <em>toggle dynamics on order ideals of a dependency poset</em> (dynamical algebraic combinatorics): the generators are involutions, their compositions yield rich periodicity (rowmotion), and the resulting permutation representation is a concrete “space of project reconfigurations.”
  </p>

  <div class="panel">
    <h2>1) A quick critique of the earlier draft (what it does, what it leaves on the table)</h2>
    <p>
      The earlier page (i) correctly defines a group action and (ii) gives a clean interactive <span class="mono">S<sub>3</sub></span> permutation model of reordering three tasks, complete with a Cayley table and composition highlighting; it’s a good “first contact” with actions-as-bijections.
      But it implicitly equates “project control” with “reordering,” and that’s exactly where the mathematics becomes decorative: real project structure lives in <em>partial orders</em> (prerequisites), <em>irreversibility</em> (execution vs planning), and <em>quotients</em> (“different plans, same outcome/invariant”).
    </p>
    <p class="callout">
      If you only keep one upgrade principle: <strong>use group actions to define and exploit equivalence classes of project states</strong> (orbits), and interpret constraints as stabilisers (what cannot move) rather than as “special cases.”
    </p>
  </div>

  <h2>2) A working schema: what groups buy you in projects (when used aggressively)</h2>
  <div class="panel">
    <p>
      Think of a project as a triple <span class="pill">(S, A, f)</span> where <span class="pill">S</span> is a state space (what you choose to remember), <span class="pill">A</span> is an algebra of moves (group / groupoid / monoid), and <span class="pill">f : S → ℝ</span> is an evaluation functional (cost, risk, learning, value).
      Groups matter because they let you (a) <em>move around without changing “the thing”</em> (symmetry / gauge), and (b) compute invariants or quotient out redundancy so you search in a smaller space.
    </p>

    <details>
      <summary>Less popular but useful distinctions (group vs monoid vs groupoid)</summary>
      <div class="small">
        <p>
          A group is the right model for <em>reversible reconfigurations</em> (renaming, refactoring that preserves behaviour, changing granularity under an agreed equivalence, swapping independent operations). Execution often isn’t reversible, so the honest algebra is usually a <em>monoid</em> (composition without inverses) or a <em>category</em> (many objects/states, arrows as feasible transitions).
          A pragmatic hack (with a long pedigree) is to take your non-invertible move system and study the associated “symmetry shadow”: stabilisers, automorphisms, and group completions that act on the parts you can legitimately treat as reversible.
        </p>
      </div>
    </details>

    <details>
      <summary>How the group-theoretic vocabulary maps to project cognition</summary>
      <div class="small">
        <ul>
          <li><span class="pill">Orbit</span>: “all plans that are the same up to harmless reconfiguration.”</li>
          <li><span class="pill">Stabiliser</span>: “what must stay fixed for this notion of sameness to hold” (constraints, invariants, commitments).</li>
          <li><span class="pill">Quotient S/G</span>: “a compressed space of genuinely distinct situations.”</li>
          <li><span class="pill">Schreier graph</span>: “local neighbourhood of alternatives under your generating moves” (a navigation map, not a philosophy).</li>
          <li><span class="pill">Normal form</span>: “canonical representative of an equivalence class” (how you keep meetings short).</li>
        </ul>
      </div>
    </details>
  </div>

  <h2>3) Interactive core: dependencies as a poset, progress as an order ideal, reconfiguration as a toggle group</h2>
  <p class="small">
    Model prerequisites as a finite poset <span class="mono">(P, ≤)</span>. A “valid set of completed tasks” is an <em>order ideal</em> <span class="mono">I ⊆ P</span> (downward closed: if <span class="mono">x ∈ I</span> then all prerequisites of <span class="mono">x</span> lie in <span class="mono">I</span>).
    Each task <span class="mono">t</span> induces a <em>toggle</em> (an involution on ideals): add <span class="mono">t</span> if it becomes available; remove <span class="mono">t</span> only if nothing completed depends on it.
    These toggles generate a subgroup of a symmetric group acting on the finite set <span class="mono">J(P)</span> of ideals; rowmotion is a canonical composite with surprisingly rigid orbit structure.
  </p>

  <div class="grid">
    <div class="panel">
      <h3>Choose a dependency poset</h3>
      <div class="row">
        <label for="posetSelect"><strong>Preset:</strong></label>
        <select id="posetSelect"></select>
        <button class="secondary" id="resetBtn">Reset state</button>
      </div>
      <div class="small muted">
        Tip: pick the “Fork-Join” example to see non-trivial orbit structure without too many states.
      </div>

      <div class="hr"></div>

      <h3>Current project state (an order ideal)</h3>
      <div id="taskContainer"></div>

      <div class="row">
        <button id="rowmotionBtn">Apply rowmotion</button>
        <button id="toggleSweepBtn" class="secondary">Apply a toggle sweep (Coxeter-like element)</button>
        <button id="undoBtn" class="secondary">Undo last move</button>
        <button id="clearHistoryBtn" class="danger">Clear history</button>
      </div>

      <div class="kbox">
        <div><strong>State:</strong> <span id="stateDisplay" class="mono"></span></div>
        <div><strong>Available adds:</strong> <span id="addsDisplay"></span></div>
        <div><strong>Available removes:</strong> <span id="remsDisplay"></span></div>
        <div class="small muted" id="moveLog"></div>
      </div>
    </div>

    <div class="panel">
      <h3>Orbit diagnostics (rowmotion)</h3>
      <p class="small">
        Rowmotion is a permutation of the ideal set <span class="mono">J(P)</span>. The orbit through your current state is a concrete “rhythm of progress”: a cycle whose length is an invariant of the chosen state under this dynamics.
      </p>

      <div class="row">
        <button class="secondary" id="computeOrbitBtn">Compute orbit from current state</button>
        <button class="secondary" id="showAllIdealsBtn">Show all ideals & rowmotion image</button>
      </div>

      <div class="kbox" id="orbitBox">
        <div><strong># ideals |J(P)|:</strong> <span id="idealCount"></span></div>
        <div><strong>Rowmotion orbit length from current:</strong> <span id="orbitLen"></span></div>
        <div><strong>Orbit (as a cycle):</strong></div>
        <div id="orbitCycle" class="mono small"></div>
      </div>

      <details id="allIdealsDetails">
        <summary>All ideals (bitmask, set, rowmotion image, orbit id)</summary>
        <div class="kbox" style="margin-top:10px;">
          <div id="allIdealsTableWrap"></div>
        </div>
      </details>
    </div>
  </div>

  <h2>4) Schreier-graph thinking: shortest “reconfiguration word” between two valid states</h2>
  <div class="panel">
    <p class="small">
      Once you have generators (toggles) acting on a set (ideals), you can treat the induced graph as a Schreier graph: vertices are states, edges are generator applications.
      For project thinking, this is a disciplined way to answer “how many small legal moves away is that other configuration?” and “what’s a minimal sequence of reversible adjustments?”
    </p>

    <div class="row">
      <label for="targetSelect"><strong>Target state:</strong></label>
      <select id="targetSelect"></select>
      <button class="secondary" id="shortestPathBtn">Find shortest toggle word</button>
    </div>

    <div class="kbox">
      <div><strong>Distance:</strong> <span id="distDisplay"></span></div>
      <div><strong>Toggle word:</strong> <span id="wordDisplay" class="mono"></span></div>
      <div class="small muted" id="wordNote"></div>
    </div>
  </div>

  <h2>5) If you want to push the abstraction further (without losing contact with practice)</h2>
  <div class="panel">
    <p>
      The “poset + toggle group” story is unusually honest: it respects prerequisites and gives a real group action on a real project-relevant state space.
      From there the ambitious move is to treat much of project discourse as <em>gauge</em>: different representations of the same underlying commitments; quotient early and often.
      The obscure-but-productive bridge is to view each project meeting as an attempt to choose a good <em>section</em> of the quotient map <span class="mono">S → S/G</span> (a canonical representative), which is exactly why “normal forms” are a cognitive technology, not just a maths trick.
    </p>
    <details>
      <summary>Scholarly rabbit holes (names you can actually look up)</summary>
      <div class="small">
        <ul>
          <li><strong>Dynamical algebraic combinatorics</strong>: toggle groups, rowmotion (Fon-der-Flaass; Propp–Roby; Striker–Williams).</li>
          <li><strong>Distributive lattices</strong>: Birkhoff’s representation theorem (ideals of a poset as a lattice).</li>
          <li><strong>Trace theory / concurrency</strong>: Cartier–Foata normal form, Mazurkiewicz traces (for “independent tasks commute”).</li>
          <li><strong>Schreier/Cayley graphs</strong>: local exploration of state spaces under generators (a geometry of alternatives).</li>
          <li><strong>Groupoids & categories</strong>: when “moves” are only partially defined or irreversible (workflow as a small category).</li>
        </ul>
      </div>
    </details>
  </div>

  <p class="small muted">
    Implementation note: everything below is self-contained JavaScript; no external libraries, no network calls.
  </p>

<script>
/* ===========================================================
   DATA MODEL
   =========================================================== */

const PRESETS = [
  {
    id: "fork_join",
    name: "Fork-Join (5 tasks)",
    tasks: [
      { id:"A", name:"A — Requirements", prereq:[] },
      { id:"B", name:"B — Design", prereq:["A"] },
      { id:"C", name:"C — Data/Research", prereq:["A"] },
      { id:"D", name:"D — Implementation", prereq:["B","C"] },
      { id:"E", name:"E — Validation/Release", prereq:["D"] }
    ]
  },
  {
    id: "diamond",
    name: "Diamond (4 tasks)",
    tasks: [
      { id:"A", name:"A — Start", prereq:[] },
      { id:"B", name:"B — Branch 1", prereq:["A"] },
      { id:"C", name:"C — Branch 2", prereq:["A"] },
      { id:"D", name:"D — Merge", prereq:["B","C"] }
    ]
  },
  {
    id: "two_streams",
    name: "Two Streams + Integration (6 tasks)",
    tasks: [
      { id:"A", name:"A — Problem framing", prereq:[] },
      { id:"B", name:"B — Stream 1: Build", prereq:["A"] },
      { id:"C", name:"C — Stream 2: Evaluate", prereq:["A"] },
      { id:"D", name:"D — Stream 1: Harden", prereq:["B"] },
      { id:"E", name:"E — Stream 2: Calibrate", prereq:["C"] },
      { id:"F", name:"F — Integration/Decision", prereq:["D","E"] }
    ]
  }
];

let currentPreset = PRESETS[0];
let tasks = [];          // array of task objects
let indexOf = {};        // task id -> index
let n = 0;

let ancestors = [];      // ancestors[i] bitmask of prerequisites (transitive)
let descendants = [];    // descendants[i] bitmask of dependents (transitive)

// The set of ideals (order ideals) as bitmasks
let ideals = [];         // array of masks
let idealIndex = new Map(); // mask -> idx
let rowmotionMap = new Map(); // mask -> mask

// togglePerms[i]: function mask -> newMask
let togglePerms = [];    // array of Maps? we will compute directly

// state + history
let stateMask = 0;
let history = [];        // stack of previous masks
let moveHistory = [];    // stack of move description

/* ===========================================================
   UTILITIES
   =========================================================== */

function maskToSetString(mask){
  const ids = [];
  for (let i=0;i<n;i++){
    if (mask & (1<<i)) ids.push(tasks[i].id);
  }
  return "{" + ids.join(", ") + "}";
}

function maskToVerboseString(mask){
  const items = [];
  for (let i=0;i<n;i++){
    if (mask & (1<<i)) items.push(tasks[i].name);
  }
  return items.length ? items.join("; ") : "(empty)";
}

function topoOrder(){
  // A simple Kahn topo sort for display / sweep order (posets here are small).
  const indeg = new Array(n).fill(0);
  const adj = new Array(n).fill(0).map(()=>[]);
  for (let i=0;i<n;i++){
    for (const p of tasks[i].prereq){
      const pi = indexOf[p];
      adj[pi].push(i);
      indeg[i] += 1;
    }
  }
  const q = [];
  for (let i=0;i<n;i++) if (indeg[i]===0) q.push(i);
  const out = [];
  while (q.length){
    q.sort((a,b)=> tasks[a].id.localeCompare(tasks[b].id));
    const v = q.shift();
    out.push(v);
    for (const u of adj[v]){
      indeg[u] -= 1;
      if (indeg[u]===0) q.push(u);
    }
  }
  // if cycle (should not happen in presets), return identity
  if (out.length !== n) return [...Array(n).keys()];
  return out;
}

/* ===========================================================
   POSET PRECOMPUTATION
   =========================================================== */

function computeTransitiveClosure(){
  // Build direct prereq adjacency (lower edges) and direct dependent edges (upper edges)
  const prereqMask = new Array(n).fill(0);
  const depMask = new Array(n).fill(0);

  for (let i=0;i<n;i++){
    for (const p of tasks[i].prereq){
      const pi = indexOf[p];
      prereqMask[i] |= (1<<pi);
      depMask[pi] |= (1<<i);
    }
  }

  // Floyd-Warshall style transitive closure on bitmasks
  ancestors = prereqMask.slice();
  descendants = depMask.slice();

  // compute ancestors transitively
  // if j is a prereq of i, then ancestors[i] includes ancestors[j] too.
  let changed = true;
  while (changed){
    changed = false;
    for (let i=0;i<n;i++){
      let a = ancestors[i];
      // for each bit j in a, union ancestors[j]
      let tmp = a;
      while (tmp){
        const j = Math.floor(Math.log2(tmp & -tmp));
        a |= ancestors[j];
        tmp &= (tmp - 1);
      }
      if (a !== ancestors[i]) { ancestors[i] = a; changed = true; }
    }
  }

  // compute descendants transitively
  changed = true;
  while (changed){
    changed = false;
    for (let i=0;i<n;i++){
      let d = descendants[i];
      let tmp = d;
      while (tmp){
        const j = Math.floor(Math.log2(tmp & -tmp));
        d |= descendants[j];
        tmp &= (tmp - 1);
      }
      if (d !== descendants[i]) { descendants[i] = d; changed = true; }
    }
  }
}

function isIdeal(mask){
  // Downward closed: for every i in mask, ancestors[i] subset of mask
  for (let i=0;i<n;i++){
    if (mask & (1<<i)){
      if ((ancestors[i] & mask) !== ancestors[i]) return false;
    }
  }
  return true;
}

function generateIdeals(){
  ideals = [];
  idealIndex = new Map();

  const total = 1<<n;
  for (let mask=0; mask<total; mask++){
    if (isIdeal(mask)){
      idealIndex.set(mask, ideals.length);
      ideals.push(mask);
    }
  }
}

function availableAdds(mask){
  const add = [];
  for (let i=0;i<n;i++){
    if (!(mask & (1<<i))){
      // can add i if all ancestors are already in mask
      if ((ancestors[i] & mask) === ancestors[i]) add.push(i);
    }
  }
  return add;
}

function availableRemoves(mask){
  const rem = [];
  for (let i=0;i<n;i++){
    if (mask & (1<<i)){
      // can remove i if no descendant of i is in mask
      if ((descendants[i] & mask) === 0) rem.push(i);
    }
  }
  return rem;
}

function toggle(mask, i){
  // involution on ideals: try add else try remove else unchanged
  if (!(mask & (1<<i))){
    if ((ancestors[i] & mask) === ancestors[i]){
      return mask | (1<<i);
    }
    return mask;
  } else {
    if ((descendants[i] & mask) === 0){
      return mask & ~(1<<i);
    }
    return mask;
  }
}

function buildRowmotion(){
  rowmotionMap = new Map();
  for (const mask of ideals){
    // minimal elements of complement: x not in I whose ancestors ⊆ I
    const mins = [];
    for (let i=0;i<n;i++){
      if (!(mask & (1<<i))){
        if ((ancestors[i] & mask) === ancestors[i]) mins.push(i);
      }
    }
    // ideal generated by mins: include each min and its ancestors
    let out = 0;
    for (const i of mins){
      out |= (1<<i);
      out |= ancestors[i];
    }
    // out is an ideal by construction
    rowmotionMap.set(mask, out);
  }
}

function orbitUnderRowmotion(startMask){
  const seen = new Map(); // mask -> step index
  const seq = [];
  let cur = startMask;
  let step = 0;
  while (!seen.has(cur)){
    seen.set(cur, step);
    seq.push(cur);
    cur = rowmotionMap.get(cur);
    step += 1;
    // safety: shouldn't exceed |ideals|
    if (step > ideals.length + 5) break;
  }
  const cycleStart = seen.get(cur);
  const cycle = seq.slice(cycleStart);
  return { seq, cycle, cycleStart };
}

/* ===========================================================
   UI RENDERING
   =========================================================== */

function el(tag, attrs={}, children=[]){
  const node = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)){
    if (k === "class") node.className = v;
    else if (k === "html") node.innerHTML = v;
    else node.setAttribute(k, v);
  }
  for (const c of children){
    if (typeof c === "string") node.appendChild(document.createTextNode(c));
    else node.appendChild(c);
  }
  return node;
}

function renderPresets(){
  const sel = document.getElementById("posetSelect");
  sel.innerHTML = "";
  for (const p of PRESETS){
    const opt = el("option", { value: p.id }, [p.name]);
    sel.appendChild(opt);
  }
  sel.value = currentPreset.id;
}

function setPresetById(id){
  const p = PRESETS.find(x => x.id === id) || PRESETS[0];
  currentPreset = p;

  tasks = p.tasks.map(t => ({...t}));
  n = tasks.length;
  indexOf = {};
  for (let i=0;i<n;i++) indexOf[tasks[i].id] = i;

  computeTransitiveClosure();
  generateIdeals();
  buildRowmotion();

  // reset state
  stateMask = 0;
  history = [];
  moveHistory = [];
  updateAll();
}

function pushHistory(desc){
  history.push(stateMask);
  moveHistory.push(desc);
  document.getElementById("undoBtn").disabled = history.length === 0;
}

function undo(){
  if (!history.length) return;
  stateMask = history.pop();
  const desc = moveHistory.pop();
  updateAll();
}

function clearHistory(){
  history = [];
  moveHistory = [];
  document.getElementById("undoBtn").disabled = true;
  updateAllMoveLog();
}

function updateAll(){
  updateTaskList();
  updateStateBox();
  updateOrbitBoxCounts();
  updateTargetSelect();
  updateAllMoveLog();
}

function updateAllMoveLog(){
  const log = document.getElementById("moveLog");
  if (!moveHistory.length){
    log.textContent = "Move log: (none yet)";
    return;
  }
  const tail = moveHistory.slice(-8);
  log.innerHTML = "Move log (latest last):<br/>" + tail.map((x,i)=> `${moveHistory.length - tail.length + i + 1}. ${x}`).join("<br/>");
}

function updateStateBox(){
  document.getElementById("stateDisplay").textContent = maskToSetString(stateMask) + "  // " + maskToVerboseString(stateMask);

  const adds = availableAdds(stateMask);
  const rems = availableRemoves(stateMask);

  const addsSpan = document.getElementById("addsDisplay");
  const remsSpan = document.getElementById("remsDisplay");
  addsSpan.innerHTML = "";
  remsSpan.innerHTML = "";

  if (!adds.length) addsSpan.appendChild(el("span", {class:"muted"}, ["(none)"]));
  if (!rems.length) remsSpan.appendChild(el("span", {class:"muted"}, ["(none)"]));

  for (const i of adds){
    addsSpan.appendChild(el("span", {class:"pill"}, [tasks[i].id]));
  }
  for (const i of rems){
    remsSpan.appendChild(el("span", {class:"pill"}, [tasks[i].id]));
  }

  // disable undo button
  document.getElementById("undoBtn").disabled = history.length === 0;
}

function taskStatus(i, mask){
  const inI = !!(mask & (1<<i));
  if (inI){
    // removable?
    const removable = ((descendants[i] & mask) === 0);
    return removable ? "done" : "done"; // still done; removability shown separately
  } else {
    const available = ((ancestors[i] & mask) === ancestors[i]);
    return available ? "available" : "blocked";
  }
}

function prereqList(i){
  const ps = tasks[i].prereq;
  if (!ps.length) return "(none)";
  return ps.join(", ");
}

function blockingReasons(i, mask){
  // return which prereqs missing
  const missing = [];
  for (const p of tasks[i].prereq){
    const pi = indexOf[p];
    if (!(mask & (1<<pi))) missing.push(p);
  }
  return missing;
}

function renderTask(i){
  const status = taskStatus(i, stateMask);
  const inI = !!(stateMask & (1<<i));
  const removable = inI && ((descendants[i] & stateMask) === 0);
  const available = !inI && ((ancestors[i] & stateMask) === ancestors[i]);

  const checkbox = el("input", {type:"checkbox"});
  checkbox.checked = inI;
  checkbox.addEventListener("change", () => {
    // user intent: if checked then add, else remove; but obey toggle legality
    const before = stateMask;
    let after = before;

    if (checkbox.checked){
      // try add
      after = toggle(before, i);
      if (after === before){
        checkbox.checked = false;
      } else {
        pushHistory(`toggle ${tasks[i].id} (add)`);
        stateMask = after;
      }
    } else {
      // try remove
      after = toggle(before, i);
      if (after === before){
        checkbox.checked = true;
      } else {
        pushHistory(`toggle ${tasks[i].id} (remove)`);
        stateMask = after;
      }
    }
    updateAll();
  });

  const title = el("div", {class:"title"}, [tasks[i].name]);
  const badge = el("span", {class:"badge " + status}, [
    status === "done" ? "in ideal" : (status === "available" ? "available" : "blocked")
  ]);

  title.appendChild(badge);

  // Build detail line: prereqs and whether removable
  const prereqLine = el("div", {class:"small"}, [
    el("span", {class:"muted"}, ["Prereqs: "]),
    el("span", {class:"mono"}, [prereqList(i)])
  ]);

  const detailBits = [];
  if (!inI && !available){
    const miss = blockingReasons(i, stateMask);
    if (miss.length){
      detailBits.push(el("div", {class:"small"}, [
        el("span", {class:"warn"}, ["Blocked by missing: "]),
        el("span", {class:"mono"}, [miss.join(", ")])
      ]));
    }
  }
  if (inI && !removable){
    // find a dependent in ideal
    const deps = [];
    for (let j=0;j<n;j++){
      if (j!==i && (stateMask & (1<<j)) && (ancestors[j] & (1<<i))){
        deps.push(tasks[j].id);
      }
    }
    if (deps.length){
      detailBits.push(el("div", {class:"small"}, [
        el("span", {class:"warn"}, ["Not removable (supports: "]),
        el("span", {class:"mono"}, [deps.join(", ")]),
        el("span", {class:"warn"}, [")"])
      ]));
    }
  }

  const meta = el("div", {class:"meta"}, [title, prereqLine, ...detailBits]);

  return el("div", {class:"task"}, [checkbox, meta]);
}

function updateTaskList(){
  const cont = document.getElementById("taskContainer");
  cont.innerHTML = "";
  for (let i=0;i<n;i++){
    cont.appendChild(renderTask(i));
  }
}

function updateOrbitBoxCounts(){
  document.getElementById("idealCount").textContent = ideals.length.toString();
  document.getElementById("orbitLen").textContent = "(not computed)";
  document.getElementById("orbitCycle").textContent = "";
  document.getElementById("distDisplay").textContent = "(not computed)";
  document.getElementById("wordDisplay").textContent = "";
  document.getElementById("wordNote").textContent = "";
}

function computeOrbitUI(){
  const {cycle} = orbitUnderRowmotion(stateMask);
  document.getElementById("orbitLen").textContent = cycle.length.toString();
  document.getElementById("orbitCycle").textContent = cycle.map(maskToSetString).join("  →  ");
}

function buildAllIdealsTable(){
  // compute orbit ids for rowmotion
  const orbitId = new Map(); // mask -> id
  let nextId = 1;
  for (const mask of ideals){
    if (orbitId.has(mask)) continue;
    const {cycle} = orbitUnderRowmotion(mask);
    for (const m of cycle) orbitId.set(m, nextId);
    nextId += 1;
  }

  const table = el("table");
  const thead = el("thead");
  const thr = el("tr");
  ["mask", "ideal (set)", "rowmotion(ideal)", "rowmotion orbit id"].forEach(h => thr.appendChild(el("th", {}, [h])));
  thead.appendChild(thr);
  table.appendChild(thead);

  const tbody = el("tbody");
  for (const mask of ideals){
    const tr = el("tr");
    tr.appendChild(el("td", {class:"mono"}, [mask.toString()]));
    tr.appendChild(el("td", {class:"mono"}, [maskToSetString(mask)]));
    tr.appendChild(el("td", {class:"mono"}, [maskToSetString(rowmotionMap.get(mask))]));
    tr.appendChild(el("td", {class:"mono"}, [orbitId.get(mask).toString()]));
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);

  const wrap = document.getElementById("allIdealsTableWrap");
  wrap.innerHTML = "";
  wrap.appendChild(table);
}

function updateTargetSelect(){
  const sel = document.getElementById("targetSelect");
  sel.innerHTML = "";
  // Offer all ideals, but order by size then lexicographic for readability
  const sorted = ideals.slice().sort((a,b)=>{
    const sa = popcount(a), sb = popcount(b);
    if (sa !== sb) return sa - sb;
    return a - b;
  });
  for (const mask of sorted){
    const opt = el("option", {value: mask.toString()}, [maskToSetString(mask)]);
    sel.appendChild(opt);
  }
  sel.value = stateMask.toString();
}

function popcount(x){
  let c=0;
  while (x){ x &= (x-1); c++; }
  return c;
}

/* ===========================================================
   OPERATIONS: ROWMOTION, TOGGLE SWEEP, SHORTEST WORD
   =========================================================== */

function applyRowmotion(){
  pushHistory("rowmotion");
  stateMask = rowmotionMap.get(stateMask);
  updateAll();
}

function applyToggleSweep(){
  // A fixed composition of toggles (a “Coxeter-like” element): toggle in topo order.
  const order = topoOrder();
  pushHistory("toggle sweep [" + order.map(i=>tasks[i].id).join(" ") + "]");
  let cur = stateMask;
  for (const i of order){
    cur = toggle(cur, i);
  }
  stateMask = cur;
  updateAll();
}

function shortestToggleWord(startMask, targetMask){
  // BFS on the undirected toggle graph (toggles are involutions)
  if (startMask === targetMask){
    return {dist:0, word:[]};
  }
  const q = [startMask];
  const prev = new Map();     // mask -> {pMask, genIndex}
  prev.set(startMask, {p:null, gen:null});
  let head = 0;

  while (head < q.length){
    const cur = q[head++];
    for (let i=0;i<n;i++){
      const nxt = toggle(cur, i);
      if (nxt === cur) continue; // illegal toggle; no edge
      if (!prev.has(nxt)){
        prev.set(nxt, {p:cur, gen:i});
        if (nxt === targetMask){
          // reconstruct
          const word = [];
          let m = nxt;
          while (m !== startMask){
            const rec = prev.get(m);
            word.push(rec.gen);
            m = rec.p;
          }
          word.reverse();
          return {dist: word.length, word};
        }
        q.push(nxt);
      }
    }
  }
  return {dist: null, word: null};
}

/* ===========================================================
   EVENT WIRING
   =========================================================== */

function wireEvents(){
  document.getElementById("posetSelect").addEventListener("change", (e)=>{
    setPresetById(e.target.value);
  });

  document.getElementById("resetBtn").addEventListener("click", ()=>{
    setPresetById(currentPreset.id);
  });

  document.getElementById("rowmotionBtn").addEventListener("click", applyRowmotion);
  document.getElementById("toggleSweepBtn").addEventListener("click", applyToggleSweep);

  document.getElementById("undoBtn").addEventListener("click", undo);
  document.getElementById("clearHistoryBtn").addEventListener("click", clearHistory);

  document.getElementById("computeOrbitBtn").addEventListener("click", computeOrbitUI);

  document.getElementById("showAllIdealsBtn").addEventListener("click", ()=>{
    buildAllIdealsTable();
    document.getElementById("allIdealsDetails").open = true;
  });

  document.getElementById("shortestPathBtn").addEventListener("click", ()=>{
    const target = parseInt(document.getElementById("targetSelect").value, 10);
    const {dist, word} = shortestToggleWord(stateMask, target);

    if (dist === 0){
      document.getElementById("distDisplay").textContent = "0";
      document.getElementById("wordDisplay").textContent = "(empty word)";
      document.getElementById("wordNote").textContent = "You are already at the target state.";
      return;
    }
    if (dist === null){
      document.getElementById("distDisplay").textContent = "∞";
      document.getElementById("wordDisplay").textContent = "(no path)";
      document.getElementById("wordNote").textContent =
        "No path exists using legal toggles (this is unusual for connected posets, but can happen if your toggle graph disconnects).";
      return;
    }
    document.getElementById("distDisplay").textContent = dist.toString();
    const wordStr = word.map(i=>`t_${tasks[i].id}`).join(" · ");
    document.getElementById("wordDisplay").textContent = wordStr;

    // verify by applying word
    let cur = stateMask;
    for (const i of word) cur = toggle(cur, i);
    const ok = (cur === target);

    document.getElementById("wordNote").textContent =
      ok ? "Verified: applying this toggle word reaches the target." : "Warning: verification failed (unexpected).";
  });
}

/* ===========================================================
   INIT
   =========================================================== */

function init(){
  renderPresets();
  wireEvents();
  setPresetById(PRESETS[0].id);
}

init();
</script>
</body>
</html>
