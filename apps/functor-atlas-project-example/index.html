<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Functorial Atlas Graph</title>
    <link rel="stylesheet" href="../../common.css" />
    <style>
      /* ---------- global look ---------- */
      body {
        margin: 0;
        font-family: system-ui, -apple-system, sans-serif;
        background: #f7f9fc;
        background-image: radial-gradient(
            circle at 20% 50%,
            rgba(20, 100, 246, 0.03) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(142, 68, 173, 0.03) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 20%,
            rgba(32, 201, 151, 0.03) 0%,
            transparent 50%
          );
      }
      #container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }
      .app-nav {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 3;
      }
      .app-nav a {
        text-decoration: none;
      }

      /* ---------- graph styling ---------- */
      .link {
        fill: none;
        stroke-width: 2;
        opacity: 0.6;
      }
      .link.functor {
        stroke: #000;
        stroke-width: 3;
        opacity: 0.8;
      }
      .link:hover {
        opacity: 1;
      }
      .node {
        cursor: pointer;
        stroke: #fff;
        stroke-width: 2;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      }
      .node:hover {
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
      }
      .hull {
        fill-opacity: 0.15;
        stroke-opacity: 0.5;
        stroke-width: 2;
        stroke-linejoin: round;
        cursor: move;
        transition: 0.2s;
      }
      .hull:hover {
        fill-opacity: 0.2;
        stroke-opacity: 0.7;
      }
      .hull.dragging {
        fill-opacity: 0.25;
        stroke-opacity: 0.8;
        stroke-width: 3;
      }
      .hull-label {
        font: 700 14px/1 system-ui;
        text-anchor: middle;
        opacity: 0.7;
        pointer-events: none;
      }
      .edge-dot {
        cursor: pointer;
        fill: #d93025;
        stroke: #fff;
        stroke-width: 2;
        opacity: 0.7;
        transition: 0.2s;
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0% {
          opacity: 0.7;
        }
        50% {
          opacity: 0.9;
        }
        100% {
          opacity: 0.7;
        }
      }
      .edge-dot:hover,
      .edge-dot.active {
        opacity: 1;
        transform: scale(1.3);
        animation: none;
      }
      .edge-dot.active {
        fill: #ff5252;
      }
      .tooltip {
        position: absolute;
        max-width: 300px;
        padding: 12px;
        font-size: 13px;
        background: rgba(50, 50, 50, 0.95);
        color: #fff;
        border-radius: 6px;
        pointer-events: none;
        opacity: 0;
        transition: 0.2s;
        line-height: 1.4;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      .legend {
        position: absolute;
        top: 20px;
        right: 20px;
        background: #fff;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        font-size: 12px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        margin: 5px 0;
      }
      .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 8px;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div class="app-nav">
        <a class="btn" href="../../index.html">Back to app index</a>
      </div>
    </div>
    <div class="tooltip"></div>
    <div class="legend">
      <h4 style="margin: 0 0 10px">Categories</h4>
      <div id="legend-items"></div>
      <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd">
        <div class="legend-item">
          <div style="width: 20px; height: 3px; background: #000; margin-right: 8px"></div>
          <span>Functors</span>
        </div>
        <div style="margin-top: 10px; font-size: 11px; color: #666">
          Colored regions show category boundaries
        </div>
      </div>
      <div
        style="
          margin-top: 15px;
          padding-top: 10px;
          border-top: 1px solid #ddd;
          font-size: 11px;
          color: #666;
        "
      >
        <strong>Instructions:</strong><br />
        • Drag nodes or whole regions<br />
        • Hover nodes for descriptions<br />
        • Click red edge dots for details
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
      /* ---------- 0. DATA ---------- */
      const categoryColors = {
        T: "#1464f6",
        S: "#20c997",
        R: "#fd7e14",
        C: "#dc3545",
        K: "#d93025",
        D: "#8e44ad",
        V: "#28a745",
        P: "#6f42c1",
        O: "#17a2b8",
        M: "#795548",
        Z: "#ff1744",
        G: "#ffc107",
        A: "#00bcd4",
        U: "#9c27b0",
      };
      const categoryNames = {
        T: "Tasks",
        S: "Schedule",
        R: "Resources",
        C: "Costs",
        K: "Risks",
        D: "Deliverables",
        V: "Verification",
        P: "Stakeholders",
        O: "Order",
        M: "Models",
        Z: "Telemetry",
        G: "Goals",
        A: "Actors",
        U: "Quality",
      };
      const EX_CAT_DATA = {
        T: {
          objects: [
            "T1: Design Wireframes",
            "T2: Build Frontend",
            "T3: Deploy to Cloud",
            "T4: QA Testing",
          ],
          morphisms: ["T1 → T2", "T2 → T4", "T3 → T4"],
        },
        S: {
          objects: [
            "S1: 1 Jul–5 Jul (Design)",
            "S2: 6 Jul–15 Jul (Build)",
            "S3: 10 Jul–12 Jul (Deploy)",
            "S4: 16 Jul–18 Jul (Test)",
          ],
          morphisms: ["S1 precedes S2", "S2 overlaps S3", "S3 precedes S4"],
        },
        R: {
          objects: [
            "R1: Designer 40 h",
            "R2: FE Dev 80 h",
            "R3: DevOps 24 h",
            "R4: QA 24 h",
          ],
          morphisms: ["Allocate R1 to T1", "Allocate R2 to T2"],
        },
        C: {
          objects: [
            "C1: $2 k Design",
            "C2: $6 k Build",
            "C3: $1 k Deploy",
            "C4: $2 k Test",
          ],
          morphisms: ["C1 accrues 1 Jul–5 Jul", "C2 accrues 6 Jul–15 Jul"],
        },
        K: {
          objects: ["K1: Scope Creep", "K2: Server Outage"],
          morphisms: ["K1 escalates K2"],
        },
        D: {
          objects: ["D1: Responsive Microsite", "D2: CI/CD Pipeline"],
          morphisms: ["D1 decomposes {T1,T2,T3,T4}", "D2 decomposes {T3}"],
        },
        V: {
          objects: ["V1: Lighthouse ≥ 90", "V2: All E2E Tests Pass"],
          morphisms: ["V2 verifies D1"],
        },
        P: {
          objects: ["P1: Client", "P2: Project Manager", "P3: Dev Team"],
          morphisms: ["Updates P2 → P1", "Updates P3 → P2"],
        },
        O: {
          objects: ["O1: Design Approved", "O2: Code Complete", "O3: Site Live"],
          morphisms: ["O1 ≤ O2", "O2 ≤ O3"],
        },
        M: {
          objects: ["M1: Completion N(15 d, σ 3 d)"],
          morphisms: ["PERT aggregation"],
        },
        Z: {
          objects: ["Z1: Git commit stream", "Z2: Monitoring logs"],
          morphisms: ["Daily commit histogram"],
        },
        G: {
          objects: ["G1: Increase Leads", "G2: Modern Brand Presence"],
          morphisms: ["G1 supports D1", "G2 supports D1"],
        },
        A: {
          objects: [
            "A1: Alice (Designer)",
            "A2: Bob (Developer)",
            "A3: Charlie (DevOps)",
            "A4: Dana (QA)",
          ],
          morphisms: ["A1 reports to A2"],
        },
        U: {
          objects: ["U1: Page load < 2 s", "U2: WCAG AA"],
          morphisms: ["Trade-off U1 vs U2"],
        },
      };
      const EX_FUN_DATA = {
        F: [
          ["T1", "S1"],
          ["T2", "S2"],
          ["T3", "S3"],
          ["T4", "S4"],
        ],
        L: [
          ["T1", "C1"],
          ["T2", "C2"],
          ["T3", "C3"],
          ["T4", "C4"],
        ],
        Res: [
          ["T1", "R1"],
          ["T2", "R2"],
          ["T3", "R3"],
          ["T4", "R4"],
        ],
        Q: [["T4", "V2"]],
        Ord: [
          ["T1", "O1"],
          ["T2", "O2"],
          ["T3", "O2"],
          ["T4", "O3"],
        ],
        W: [
          ["D1", "{T1,T2,T3,T4}"],
          ["D2", "{T3}"],
        ],
        Strat: [
          ["G1", "D1"],
          ["G2", "D1"],
        ],
        J: [
          ["T3", "P1"],
          ["T2", "P2"],
        ],
        H: [
          ["K1", "T2"],
          ["K2", "T3"],
        ],
        Ω: [
          ["K1", "C2"],
          ["K2", "C3"],
        ],
        Δ: [["T2", "T2′ (revised)"]],
        Φ: [["O3", "M1"]],
        Tel: [
          ["T2", "Z1"],
          ["T3", "Z2"],
        ],
        Assign: [
          ["T1", "A1"],
          ["T2", "A2"],
          ["T3", "A3"],
          ["T4", "A4"],
        ],
        Qual: [
          ["T2", "U1"],
          ["T4", "U2"],
        ],
      };
      const functorNames = {
        F: "F: T → S (Schedule)",
        L: "L: T → C (Costing)",
        Res: "Res: T → R (Resource)",
        Q: "Q: T → V (Verification)",
        Ord: "Ord: T → O (Milestones)",
        W: "W: D → T (WBS)",
        Strat: "Strat: G → D (Strategy)",
        J: "J: T → P (Comms)",
        H: "H: Kᵒᵖ → T (Risk)",
        Ω: "Ω: K → C (Contingency)",
        Δ: "Δ: T ⇢ T (Change)",
        Φ: "Φ: O → M (Forecast)",
        Tel: "Tel: T → Z (Telemetry)",
        Assign: "Assign: T → A (Team)",
        Qual: "Qual: T → U (Quality)",
      };

      /* ---------- 1. SCENE ---------- */
      const width = innerWidth,
        height = innerHeight;
      const svg = d3.select("#container").append("svg").attr("width", width).attr("height", height);
      const g = svg.append("g");
      svg.call(
        d3.zoom().scaleExtent([0.1, 4]).on("zoom", (e) => g.attr("transform", e.transform))
      );

      /* markers first */
      const defs = svg.append("defs");
      Object.entries(categoryColors).forEach(([k, c]) => {
        defs
          .append("marker")
          .attr("id", `arrow-${k}`)
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 25)
          .attr("refY", 0)
          .attr("markerWidth", 6)
          .attr("markerHeight", 6)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M0,-5L10,0L0,5")
          .attr("fill", c);
      });
      defs
        .append("marker")
        .attr("id", "arrow-functor")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 25)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#000");

      /* layers */
      const hullGroup = g.append("g"),
        linkGroup = g.append("g"),
        edgeDotGroup = g.append("g"),
        nodeGroup = g.append("g");

      /* ---------- 2. BUILD ---------- */
      const nodes = [],
        nodeMap = {},
        links = [];
      const angle = (2 * Math.PI) / Object.keys(EX_CAT_DATA).length,
        rad = Math.min(width, height) * 0.3;
      Object.entries(EX_CAT_DATA).forEach(([c, { objects }], i) => {
        const base = {
          x: width / 2 + Math.cos(i * angle) * rad,
          y: height / 2 + Math.sin(i * angle) * rad,
        };
        objects.forEach((o) => {
          const id = o.split(":")[0].trim();
          const n = {
            id,
            label: o,
            category: c,
            color: categoryColors[c],
            x: base.x + (Math.random() - 0.5) * 100,
            y: base.y + (Math.random() - 0.5) * 100,
          };
          nodes.push(n);
          nodeMap[id] = n;
        });
      });
      if (!nodeMap["T2′"]) {
        const p = nodes.find((n) => n.id === "T2") || { x: width / 2, y: height / 2 };
        const n = {
          id: "T2′",
          label: "T2′ (revised)",
          category: "T",
          color: categoryColors.T,
          x: p.x + 60,
          y: p.y,
        };
        nodes.push(n);
        nodeMap["T2′"] = nodeMap["T2′ (revised)"] = n;
      }

      function addLink(s, t, label, c) {
        if (nodeMap[s] && nodeMap[t])
          links.push({
            source: s,
            target: t,
            label: label,
            type: "morphism",
            category: c,
            color: categoryColors[c],
          });
      }
      Object.entries(EX_CAT_DATA).forEach(([c, { morphisms }]) => {
        morphisms.forEach((m) => {
          if (m.includes("→")) {
            const [a, b] = m.split("→").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("precedes")) {
            const [a, b] = m.split("precedes").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("overlaps")) {
            const [a, b] = m.split("overlaps").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("≤")) {
            const [a, b] = m.split("≤").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("escalates")) {
            const [a, b] = m.split("escalates").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("verifies")) {
            const [a, b] = m.split("verifies").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("reports to")) {
            const [a, b] = m.split("reports to").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.includes("supports")) {
            const [a, b] = m.split("supports").map((d) => d.trim());
            addLink(a, b, m, c);
          } else if (m.startsWith("Allocate")) {
            const m2 = m.match(/Allocate (\w+) to (\w+)/);
            m2 && addLink(m2[1], m2[2], m, c);
          } else if (m.startsWith("Updates")) {
            const m2 = m.match(/Updates (\w+) → (\w+)/);
            m2 && addLink(m2[1], m2[2], m, c);
          } else if (m.startsWith("Trade-off")) {
            const m2 = m.match(/Trade-off (\w+) vs (\w+)/);
            m2 && addLink(m2[1], m2[2], m, c);
          }
        });
      });
      Object.entries(EX_FUN_DATA).forEach(([fid, map]) => {
        map.forEach(([s, t]) => {
          if (t.startsWith("{")) return;
          if (t === "T2′ (revised)") t = "T2′";
          if (nodeMap[s] && nodeMap[t])
            links.push({
              source: s,
              target: t,
              label: functorNames[fid],
              type: "functor",
              color: "#000",
            });
        });
      });

      /* ---------- 3. DRAW ---------- */
      const link = linkGroup
        .selectAll("line")
        .data(links)
        .enter()
        .append("line")
        .attr("class", (d) => (d.type === "functor" ? "link functor" : "link"))
        .attr("stroke", (d) => d.color)
        .attr("marker-end", (d) =>
          d.type === "functor" ? "url(#arrow-functor)" : `url(#arrow-${d.category})`
        );
      const edgeDots = edgeDotGroup
        .selectAll("circle")
        .data(links)
        .enter()
        .append("circle")
        .attr("class", "edge-dot")
        .attr("r", 6);
      const node = nodeGroup
        .selectAll("g")
        .data(nodes)
        .enter()
        .append("g")
        .call(d3.drag().on("start", dragstart).on("drag", dragged).on("end", dragend));
      node.append("circle").attr("class", "node").attr("r", 20).attr("fill", (d) => d.color);
      node
        .append("text")
        .attr("fill", "#fff")
        .attr("text-anchor", "middle")
        .attr("dy", ".35em")
        .style("font", "700 12px system-ui")
        .style("pointer-events", "none")
        .text((d) => d.id);

      /* ---------- tooltips ---------- */
      const tooltip = d3.select(".tooltip");
      node
        .on("mouseover", (e, d) => {
          d3.select(e.currentTarget).select("circle").transition().duration(200).attr("r", 24);
          tooltip
            .style("opacity", 1)
            .html(`<strong>${d.id}</strong><br>${d.label}`)
            .style("left", e.pageX + 10 + "px")
            .style("top", e.pageY - 28 + "px");
        })
        .on("mouseout", (e) => {
          d3.select(e.currentTarget).select("circle").transition().duration(200).attr("r", 20);
          tooltip.style("opacity", 0);
        })
        .on("click", (e) => e.stopPropagation());
      edgeDots.on("click", function (e, d) {
        e.stopPropagation();
        const dot = d3.select(this),
          active = dot.classed("active");
        edgeDots.classed("active", false);
        if (active) {
          tooltip.style("opacity", 0);
          return;
        }
        dot.classed("active", true);
        const r = this.getBoundingClientRect();
        tooltip
          .style("opacity", 1)
          .html(`<strong>${d.type === "functor" ? "Functor" : "Morphism"}</strong><br>${d.label}`)
          .style("left", r.left + r.width / 2 + "px")
          .style("top", r.top - 10 + "px")
          .style("transform", "translateX(-50%) translateY(-100%)");
      });
      svg.on("click", () => {
        edgeDots.classed("active", false);
        tooltip.style("opacity", 0);
      });

      /* ---------- 4. HULLS ---------- */
      function updateHulls() {
        const eps = 0.0001,
          grouped = d3.group(nodes, (n) => n.category);
        const data = [...grouped]
          .map(([cat, list]) => {
            const cx = d3.mean(list, (n) => n.x),
              cy = d3.mean(list, (n) => n.y);
            if (list.length < 3) return { cat, list, cx, cy, color: categoryColors[cat] };
            const hull = d3.polygonHull(list.map((n) => [n.x, n.y]));
            if (!hull) return null;
            const padded = hull.map((p) => {
              const dx = p[0] - cx,
                dy = p[1] - cy,
                dist = Math.hypot(dx, dy) + eps;
              return [p[0] + (dx * 40) / dist, p[1] + (dy * 40) / dist];
            });
            return {
              cat,
              list,
              cx,
              cy,
              color: categoryColors[cat],
              path: "M" + padded.join("L") + "Z",
            };
          })
          .filter(Boolean);

        const h = hullGroup.selectAll("g").data(data, (d) => d.cat).join((enter) => {
          const g = enter.append("g");
          g.append("path").attr("class", "hull");
          g.append("text").attr("class", "hull-label");
          return g;
        });
        h.select("path")
          .attr("d", (d) => d.path || circleFor(d))
          .style("fill", (d) => d.color)
          .style("stroke", (d) => d.color);
        h.select("text")
          .text((d) => categoryNames[d.cat])
          .attr("x", (d) => d.cx)
          .attr("y", (d) => d.cy - 55);
      }
      function circleFor(d) {
        const n = d.list[0];
        return `M ${n.x - 35} ${n.y} A 35 35 0 1 0 ${n.x + 35} ${n.y} A 35 35 0 1 0 ${
          n.x - 35
        } ${n.y}`;
      }

      /* ---------- 5. FORCE ---------- */
      const sim = d3
        .forceSimulation(nodes)
        .force("link", d3.forceLink(links).id((d) => d.id).distance(120).strength(0.5))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide(35))
        .on("tick", () => {
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
          edgeDots
            .attr("cx", (d) => (d.source.x + d.target.x) / 2)
            .attr("cy", (d) => (d.source.y + d.target.y) / 2);
          node.attr("transform", (d) => `translate(${d.x},${d.y})`);
          updateHulls();
        })
        .on("end", zoomToFit);

      /* ---------- 6. DRAG ---------- */
      function dragstart(e, d) {
        if (!e.active) sim.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(e, d) {
        d.fx = e.x;
        d.fy = e.y;
      }
      function dragend(e, d) {
        if (!e.active) sim.alphaTarget(0);
        d.fx = d.fy = null;
      }

      /* ---------- 7. LEGEND ---------- */
      Object.entries(categoryColors).forEach(([c, col]) => {
        const item = d3.select("#legend-items").append("div").attr("class", "legend-item");
        item.append("div").attr("class", "legend-color").style("background", col);
        item.append("span").text(categoryNames[c]);
      });

      /* ---------- 8. ZOOM TO FIT ---------- */
      function zoomToFit() {
        const b = g.node().getBBox();
        if (!b.width || !b.height) return;
        const s = 0.85 * Math.min(width / b.width, height / b.height);
        svg
          .transition()
          .duration(600)
          .call(
            d3.zoom().transform,
            d3.zoomIdentity
              .translate(width / 2 - s * (b.x + b.width / 2), height / 2 - s * (b.y + b.height / 2))
              .scale(s)
          );
      }
    </script>
  </body>
</html>
