<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project Process ↔ Task Explorer</title>
  <link rel="stylesheet" href="../../common.css" />
  <style>
    :root {
      color-scheme: light;
    }

    .container {
      max-width: 1040px;
      margin: 0 auto 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .intro {
      font-size: 0.95rem;
      color: #334155;
      line-height: 1.5;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem 1rem;
      align-items: center;
    }

    .btn.primary {
      background: #10b981;
      border-color: #059669;
      color: #fff;
    }

    .btn.secondary {
      background: #e2e8f0;
      border-color: #cbd5e1;
      color: #0f172a;
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: #334155;
    }

    .view-panel {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 1rem;
      background: #f8fafc;
    }

    .svg-wrapper {
      background: #fff;
      border-radius: 10px;
      border: 1px solid #d1fae5;
      overflow-x: auto;
      padding: 0.5rem;
    }

    .task-list {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .card {
      width: 18rem;
      border-radius: 12px;
      border: 1px solid #bae6fd;
      background: #f0f9ff;
      padding: 0.9rem 1rem;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06);
    }

    .card-title {
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    .card-sub {
      font-size: 0.75rem;
      color: #475569;
    }

    .callout {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      background: #f9fafb;
      padding: 1rem;
    }

    .callout h2 {
      font-size: 1rem;
      margin: 0 0 0.75rem;
    }

    .callout ul {
      margin: 0;
      padding-left: 1.2rem;
      color: #475569;
      font-size: 0.9rem;
    }

    .legend {
      font-size: 0.8rem;
      color: #64748b;
    }

    code {
      background: #f1f5f9;
      padding: 0 0.2em;
      border-radius: 4px;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <p><a href="../../index.html">Back to app index</a></p>
  <main class="container">
    <header>
      <h1>Project Process ↔ Task Explorer</h1>
      <p class="intro">
        Coda implemented: operations now carry <em>typed input/output ports</em> (lists of state IDs), so precedence is induced by
        port-wiring (outputs feeding inputs) rather than a single <code>from → to</code> arrow. Parallel branches are just multiple
        operations sharing an input state; joins are operations whose <code>in</code> lists mention multiple prerequisite states.
      </p>
    </header>

    <section class="controls" aria-label="View toggles">
      <div class="controls">
        <button class="btn" id="stateViewButton" type="button">State View</button>
        <button class="btn" id="taskViewButton" type="button">Task View</button>
      </div>
      <label class="toggle">
        <input type="checkbox" id="transitiveToggle" checked />
        Show transitive dependencies
      </label>
      <label class="toggle">
        <input type="checkbox" id="reduceToggle" />
        Reduce dependency edges
      </label>
    </section>

    <section class="view-panel">
      <div id="stateView" class="svg-wrapper" aria-live="polite"></div>
      <div id="taskView" class="task-list" hidden></div>
      <p class="legend">Diagram uses the first input/output port for drawing, but dependency logic supports all ports.</p>
    </section>

    <section class="callout">
      <h2>Next Milestones</h2>
      <ul>
        <li>Let operations have multiple inputs/outputs and render ports explicitly (little sockets on boxes) while keeping the same DOM scaffold.</li>
        <li>Enrich ops with duration/cost/risk; compute CPM/DSM views from the same operad-algebra source of truth.</li>
        <li>Add a lax reverse mapping (tasks → plausible processes) as constraint synthesis rather than a strict functor.</li>
      </ul>
    </section>
  </main>

  <script>
    class WiringOperad {
      constructor(objects, ops) {
        this.objects = objects;
        this.ops = ops;
      }

      objectIds() {
        return new Set(this.objects.map((o) => o.id));
      }

      producersIndex() {
        const idx = new Map();
        for (const op of this.ops) {
          for (const stateId of op.out || []) {
            if (!idx.has(stateId)) idx.set(stateId, []);
            idx.get(stateId).push(op);
          }
        }
        return idx;
      }
    }

    function normalizeOps(rawOps) {
      return rawOps.map((o) => {
        const ins = Array.isArray(o.in) ? o.in : o.from ? [o.from] : [];
        const outs = Array.isArray(o.out) ? o.out : o.to ? [o.to] : [];
        return {
          id: o.id,
          label: o.label,
          in: ins,
          out: outs,
        };
      });
    }

    function directPredecessors(op, producersIdx) {
      const preds = new Map();
      for (const stateId of op.in || []) {
        const producers = producersIdx.get(stateId) || [];
        for (const p of producers) preds.set(p.id, p);
      }
      return Array.from(preds.values());
    }

    function transitivePredecessors(op, producersIdx, visited = new Set()) {
      const preds = directPredecessors(op, producersIdx);
      for (const p of preds) {
        if (!visited.has(p.id)) {
          visited.add(p.id);
          transitivePredecessors(p, producersIdx, visited);
        }
      }
      return visited;
    }

    function transitiveReduction(ops, depsMap) {
      const reduced = new Map();
      const succ = new Map();
      for (const op of ops) succ.set(op.id, new Set());
      for (const [opId, preds] of depsMap.entries()) {
        for (const p of preds) {
          if (!succ.has(p)) succ.set(p, new Set());
          succ.get(p).add(opId);
        }
      }

      function reachable(from, target, bannedEdge) {
        const queue = [from];
        const seen = new Set([from]);
        while (queue.length) {
          const current = queue.shift();
          const nexts = succ.get(current) || new Set();
          for (const next of nexts) {
            if (bannedEdge && bannedEdge[0] === current && bannedEdge[1] === next) continue;
            if (next === target) return true;
            if (!seen.has(next)) {
              seen.add(next);
              queue.push(next);
            }
          }
        }
        return false;
      }

      for (const op of ops) {
        const preds = new Set(depsMap.get(op.id) || []);
        const keep = new Set(preds);
        for (const p of preds) {
          if (reachable(p, op.id, [p, op.id])) keep.delete(p);
        }
        reduced.set(op.id, keep);
      }

      return reduced;
    }

    function operadToTasks(operad, { transitive = true, reduce = false } = {}) {
      const producersIdx = operad.producersIndex();
      const deps = new Map();

      for (const op of operad.ops) {
        if (transitive) {
          deps.set(op.id, transitivePredecessors(op, producersIdx, new Set()));
        } else {
          deps.set(op.id, new Set(directPredecessors(op, producersIdx).map((x) => x.id)));
        }
      }

      const finalDeps = reduce ? transitiveReduction(operad.ops, deps) : deps;

      return operad.ops.map((op) => ({
        id: `T_${op.id}`,
        label: op.label,
        deps: Array.from(finalDeps.get(op.id) || []).map((id) => `T_${id}`),
      }));
    }

    const statesData = [
      { id: "S0", label: "Planning" },
      { id: "S1", label: "Material Ready" },
      { id: "S2", label: "Platform Built" },
      { id: "S2b", label: "Lumber Hoisted" },
      { id: "S3", label: "Shed Complete" },
    ];

    const processesRaw = [
      { id: "P0", in: ["S0"], out: ["S1"], label: "Procure Materials" },
      { id: "P1", in: ["S1"], out: ["S2"], label: "Assemble Cliff Platform" },
      { id: "P1b", in: ["S1"], out: ["S2b"], label: "Hoist Lumber Up Cliff" },
      { id: "P2", in: ["S2"], out: ["S3"], label: "Construct Shed" },
      { id: "P2b", in: ["S2b"], out: ["S3"], label: "Bolt Shed Walls" },
    ];

    const processesData = normalizeOps(processesRaw);
    const operad = new WiringOperad(statesData, processesData);

    const stateViewButton = document.getElementById("stateViewButton");
    const taskViewButton = document.getElementById("taskViewButton");
    const transitiveToggle = document.getElementById("transitiveToggle");
    const reduceToggle = document.getElementById("reduceToggle");
    const stateView = document.getElementById("stateView");
    const taskView = document.getElementById("taskView");

    let currentView = "state";

    function svgMarkup(states, processes) {
      const stateIds = states.map((s) => s.id);
      const exists = new Set(stateIds);

      const edges = processes
        .map((p) => ({
          id: p.id,
          label: p.label,
          from: (p.in && p.in[0]) || null,
          to: (p.out && p.out[0]) || null,
        }))
        .filter((e) => e.from && e.to && exists.has(e.from) && exists.has(e.to));

      const inDeg = new Map(stateIds.map((id) => [id, 0]));
      const succ = new Map(stateIds.map((id) => [id, []]));
      const preds = new Map(stateIds.map((id) => [id, []]));

      for (const e of edges) {
        succ.get(e.from).push(e.to);
        preds.get(e.to).push(e.from);
        inDeg.set(e.to, (inDeg.get(e.to) || 0) + 1);
      }

      const queue = [];
      for (const [id, degree] of inDeg.entries()) if (degree === 0) queue.push(id);
      queue.sort();

      const topo = [];
      while (queue.length) {
        const id = queue.shift();
        topo.push(id);
        for (const t of succ.get(id) || []) {
          inDeg.set(t, inDeg.get(t) - 1);
          if (inDeg.get(t) === 0) {
            queue.push(t);
            queue.sort();
          }
        }
      }

      for (const id of stateIds) if (!topo.includes(id)) topo.push(id);

      const level = new Map(stateIds.map((id) => [id, 0]));
      for (const id of topo) {
        let best = 0;
        for (const pr of preds.get(id) || []) best = Math.max(best, (level.get(pr) || 0) + 1);
        level.set(id, best);
      }

      const byLevel = new Map();
      for (const s of states) {
        const L = level.get(s.id) || 0;
        if (!byLevel.has(L)) byLevel.set(L, []);
        byLevel.get(L).push(s);
      }

      const levelKeys = Array.from(byLevel.keys()).sort((a, b) => a - b);
      for (const L of levelKeys) {
        byLevel.get(L).sort((a, b) => a.id.localeCompare(b.id));
      }

      const marginX = 70;
      const marginY = 50;
      const xStep = 190;
      const yStep = 86;
      const boxW = 110;
      const boxH = 46;

      const pos = new Map();
      let maxRowCount = 1;
      for (const L of levelKeys) maxRowCount = Math.max(maxRowCount, byLevel.get(L).length);

      for (const L of levelKeys) {
        const col = byLevel.get(L);
        const x = marginX + L * xStep;
        const colHeight = (col.length - 1) * yStep;
        const fullHeight = (maxRowCount - 1) * yStep;
        const y0 = marginY + (fullHeight - colHeight) / 2;

        col.forEach((s, i) => {
          pos.set(s.id, { x, y: y0 + i * yStep });
        });
      }

      const svgW = Math.max(700, marginX + (levelKeys.length - 1) * xStep + 260);
      const svgH = Math.max(260, marginY + (maxRowCount - 1) * yStep + 180);

      const edgeKeyCount = new Map();
      for (const e of edges) {
        const key = `${e.from}→${e.to}`;
        edgeKeyCount.set(key, (edgeKeyCount.get(key) || 0) + 1);
      }

      const stateNodes = states
        .map((s) => {
          const p = pos.get(s.id);
          if (!p) return "";
          return `
            <g transform="translate(${p.x},${p.y})">
              <rect x="${-boxW / 2}" y="${-boxH / 2}" width="${boxW}" height="${boxH}" rx="10" fill="#a7f3d0" />
              <text text-anchor="middle" dy="4" style="font-size:12px;font-weight:600;">${s.label}</text>
              <text text-anchor="middle" dy="20" style="font-size:10px;fill:#475569;">${s.id}</text>
            </g>
          `;
        })
        .join("");

      const edgeNodes = edges
        .map((e) => {
          const a = pos.get(e.from);
          const b = pos.get(e.to);
          if (!a || !b) return "";

          const x1 = a.x + boxW / 2;
          const y1 = a.y;
          const x2 = b.x - boxW / 2;
          const y2 = b.y;

          const same = edges.filter((x) => x.from === e.from && x.to === e.to).sort((u, v) => u.id.localeCompare(v.id));
          const idx = same.findIndex((x) => x.id === e.id);
          const total = edgeKeyCount.get(`${e.from}→${e.to}`) || 1;
          const fan = total === 1 ? 0 : (idx - (total - 1) / 2) * 14;

          const midX = (x1 + x2) / 2;
          const c1x = midX;
          const c2x = midX;
          const c1y = y1 + fan;
          const c2y = y2 + fan;

          const labelX = midX;
          const labelY = (y1 + y2) / 2 - 16 + fan;

          return `
            <g>
              <path
                d="M ${x1} ${y1} C ${c1x} ${c1y} ${c2x} ${c2y} ${x2} ${y2}"
                stroke="#10b981"
                stroke-width="2"
                fill="none"
                marker-end="url(#arrow)"
              />
              <rect x="${labelX - 70}" y="${labelY - 12}" width="140" height="18" rx="8" fill="white" opacity="0.85" />
              <text x="${labelX}" y="${labelY}" text-anchor="middle" style="font-size:11px;">${e.label}</text>
            </g>
          `;
        })
        .join("");

      return `
        <svg width="100%" height="260" viewBox="0 0 ${svgW} ${svgH}" xmlns="http://www.w3.org/2000/svg">
          ${stateNodes}
          ${edgeNodes}
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L0,6 L9,3 z" fill="#10b981" />
            </marker>
          </defs>
        </svg>
      `;
    }

    function renderTasks() {
      const tasks = operadToTasks(operad, {
        transitive: transitiveToggle.checked,
        reduce: reduceToggle.checked,
      });

      taskView.innerHTML = tasks
        .map((task) => {
          const depText = task.deps.length ? `Depends on: ${task.deps.join(", ")}` : "No dependencies";
          return `
            <article class="card">
              <div class="card-title">${task.label}</div>
              <div class="card-sub">${depText}</div>
            </article>
          `;
        })
        .join("");
    }

    function updateViewButtons() {
      if (currentView === "state") {
        stateViewButton.classList.add("primary");
        stateViewButton.classList.remove("secondary");
        taskViewButton.classList.remove("primary");
        taskViewButton.classList.add("secondary");
        stateView.hidden = false;
        taskView.hidden = true;
      } else {
        taskViewButton.classList.add("primary");
        taskViewButton.classList.remove("secondary");
        stateViewButton.classList.remove("primary");
        stateViewButton.classList.add("secondary");
        stateView.hidden = true;
        taskView.hidden = false;
      }
    }

    function render() {
      stateView.innerHTML = svgMarkup(statesData, processesData);
      renderTasks();
      updateViewButtons();
    }

    stateViewButton.addEventListener("click", () => {
      currentView = "state";
      updateViewButtons();
    });

    taskViewButton.addEventListener("click", () => {
      currentView = "task";
      renderTasks();
      updateViewButtons();
    });

    transitiveToggle.addEventListener("change", () => {
      if (currentView === "task") {
        renderTasks();
      }
    });

    reduceToggle.addEventListener("change", () => {
      if (currentView === "task") {
        renderTasks();
      }
    });

    render();
  </script>
</body>
</html>
