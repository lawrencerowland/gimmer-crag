<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Local Data → Global WBS (Sheaf Playground)</title>
<link rel="stylesheet" href="../../common.css">
<style>
  :root{
    --bg:#0f172a;
    --panel:#111827;
    --panel2:#0b1220;
    --ink:#e5e7eb;
    --muted:#9ca3af;
    --accent:#22c55e;
    --warn:#f59e0b;
    --danger:#ef4444;
    --link:#60a5fa;
    --grid:#1f2937;
    --stroke:#293243;
    --shadow: rgba(0,0,0,.35);
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; margin:0; }
  body{
    background:var(--bg);
    color:var(--ink);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
  }
  a{ color:var(--link); }
  h1{ font-size:20px; margin:0 0 8px 0; letter-spacing:.2px; }
  h2{ font-size:15px; margin:16px 0 8px 0; color:var(--muted); }
  h3{ font-size:13px; margin:10px 0 6px 0; color:var(--muted); }
  small{ color:var(--muted); }
  code, pre, textarea{ font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
  button{
    background:#374151;
    color:var(--ink);
    border:1px solid #4b5563;
    border-radius:8px;
    padding:8px 10px;
    cursor:pointer;
    font-size:12px;
  }
  button:hover{ filter:brightness(1.1); }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .accent{ background:var(--accent); border-color:#16a34a; color:#041b0f; }
  .warn{ background:var(--warn); border-color:#c2410c; color:#1b0d04; }
  .danger{ background:var(--danger); border-color:#b91c1c; color:#1f0303; }
  .ghost{ background:transparent; border:1px solid #4b5563; }
  .grid{
    display:grid;
    grid-template-columns: 520px 1fr;
    gap:14px;
    height:calc(100vh - 16px);
    padding:8px;
  }
  .panel{
    background:var(--panel);
    border:1px solid var(--grid);
    border-radius:12px;
    padding:12px;
    overflow:hidden;
    box-shadow: 0 10px 20px var(--shadow);
  }
  .scroll{ overflow:auto; height:100%; }
  .row{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin:8px 0; }
  .row.tight{ margin:6px 0; }
  .grow{ flex:1; }
  .kpis{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; margin-top:8px; }
  .kpi{
    background:var(--panel2);
    border:1px dashed var(--stroke);
    border-radius:10px;
    padding:8px 10px;
    min-height:54px;
  }
  .kpi b{ display:block; font-size:11px; color:var(--muted); margin-bottom:2px; }
  .status-ok{ color:var(--accent); font-weight:700; }
  .status-warn{ color:var(--warn); font-weight:700; }
  .status-bad{ color:var(--danger); font-weight:700; }
  .pill{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    font-size:11px;
    background:var(--panel2);
    border:1px solid var(--stroke);
    color:var(--muted);
  }
  .callout{
    background: #0b1220;
    border:1px solid var(--stroke);
    border-left:4px solid var(--link);
    border-radius:10px;
    padding:10px 10px;
    margin:10px 0;
  }
  .callout.warn{ border-left-color: var(--warn); }
  .callout.ok{ border-left-color: var(--accent); }
  .callout.bad{ border-left-color: var(--danger); }
  .callout summary{ cursor:pointer; }
  .callout p{ margin:6px 0; color:var(--ink); }
  .callout small{ color:var(--muted); }
  .tabs{ display:flex; gap:6px; margin-top:10px; flex-wrap:wrap; }
  .tab-btn{
    background:transparent;
    border:1px solid var(--stroke);
    border-radius:999px;
    padding:6px 10px;
    font-size:12px;
    color:var(--muted);
  }
  .tab-btn.active{
    color:var(--ink);
    border-color:#4b5563;
    background:#0b1220;
  }
  .tab-panel{ display:none; margin-top:10px; }
  .tab-panel.active{ display:block; }

  textarea{
    width:100%;
    min-height: 280px;
    background:var(--panel2);
    color:var(--ink);
    border:1px solid var(--stroke);
    border-radius:10px;
    padding:10px;
    font-size:12px;
    line-height:1.35;
  }
  input[type="text"], input[type="number"], select{
    background:var(--panel2);
    color:var(--ink);
    border:1px solid var(--stroke);
    border-radius:8px;
    padding:6px 8px;
    font-size:12px;
  }
  input[type="number"]{ width:90px; }
  input[type="text"]{ width:160px; }
  select{ padding:6px 8px; }

  input[type="range"]{ width:160px; }

  table{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
    overflow:hidden;
    border-radius:10px;
  }
  th,td{
    border-bottom:1px solid var(--grid);
    padding:6px 8px;
    text-align:left;
    vertical-align:middle;
  }
  th{ color:var(--muted); font-weight:600; position:sticky; top:0; background: #0e1628; z-index:2; }
  tr:hover td{ background: rgba(96,165,250,.06); }

  .svgbg{
    background-image:
      linear-gradient(transparent 23px, #1f2937 24px),
      linear-gradient(90deg, transparent 23px, #1f2937 24px);
    background-size:24px 24px;
    border-radius:10px;
    padding:6px;
    border:1px solid var(--grid);
  }
  svg{
    width:100%;
    height:360px;
    border:1px solid var(--grid);
    border-radius:10px;
    background:var(--panel2);
  }
  .legend{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin: 6px 0 10px 0;}
  .legend .box{ width:12px; height:12px; display:inline-block; border-radius:2px; vertical-align:middle; margin-right:4px; }
  .tooltip{
    position:absolute;
    background: var(--panel);
    border:1px solid var(--stroke);
    padding:8px 10px;
    border-radius:10px;
    font-size:12px;
    pointer-events:none;
    display:none;
    max-width: 360px;
    box-shadow: 0 10px 20px var(--shadow);
  }
  .inspector{
    background: var(--panel2);
    border:1px solid var(--stroke);
    border-radius:10px;
    padding:10px;
    margin-top:10px;
  }
  .inspector b{ color:var(--muted); font-size:11px; display:block; margin-bottom:2px; }
  .inspector .big{ font-size:14px; font-weight:800; color:var(--ink); margin:2px 0 8px 0; }
  .mono{ font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px; color:var(--muted); }
  .muted{ color:var(--muted); }
  .hr{ height:1px; background:var(--grid); margin:10px 0; }
  .right-top{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }
  .toast{
    display:none;
    background: rgba(34,197,94,.12);
    border:1px solid rgba(34,197,94,.35);
    color: var(--ink);
    border-radius:10px;
    padding:8px 10px;
    margin-top:10px;
  }
  .toast.show{ display:block; }
  .badge{
    display:inline-block;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid var(--stroke);
    background: rgba(0,0,0,.15);
    color: var(--muted);
    font-size: 11px;
  }
  .btn-xs{
    padding:6px 8px;
    border-radius:8px;
    font-size:11px;
  }
  .danger-outline{ background:transparent; border-color: rgba(239,68,68,.6); color: var(--danger); }
  .warn-outline{ background:transparent; border-color: rgba(245,158,11,.6); color: var(--warn); }
  .ok-outline{ background:transparent; border-color: rgba(34,197,94,.6); color: var(--accent); }

  .back-link{
    display:inline-block;
    margin:12px;
  }

  /* Mobile-ish fallback */
  @media (max-width: 980px){
    .grid{ grid-template-columns: 1fr; height:auto; }
    svg{ height:320px; }
    .kpis{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<a class="back-link" href="../../index.html">Back to app index</a>
<div class="grid">
  <!-- LEFT: editor + explainers -->
  <div class="panel scroll">
    <div class="right-top">
      <div>
        <h1>Local → Global WBS (Sheaf Playground)</h1>
        <small>
          Edit tasks / dependencies / patches with the forms below (or use the raw JSON tab).
          Click <b>Compute</b> to see the graph + a scheduled “global section” attempt.
        </small>
      </div>
      <div class="row tight" style="justify-content:flex-end; margin-top:2px">
        <span class="badge">Educational mode</span>
      </div>
    </div>

    <details class="callout" open>
      <summary><b>What this is modelling (click to fold)</b></summary>
      <p>
        Think of your WBS DAG as a <i>base space</i>. Each local plan (“patch”) assigns start-times to some tasks.
        Where two patches overlap, we can compare their assignments on shared tasks: that mismatch is a Čech 1-cochain δ.
      </p>
      <p>
        If δ=0 on every overlap, the local plans are <i>compatible</i> and can “glue” into a single global assignment (a <i>global section</i>),
        subject to precedence constraints, resource caps, and time windows.
      </p>
      <small class="muted">
        This is a toy obstruction: it is not full sheaf cohomology, but it keeps the same “glueability” intuition.
      </small>
    </details>

    <details class="callout warn">
      <summary><b>Try these quick experiments</b></summary>
      <p><span class="pill">1</span> Load “Patch conflict” and watch δ jump & the conflict list populate.</p>
      <p><span class="pill">2</span> In <b>Patches</b>, align the conflicting pinned time, then recompute: δ should drop.</p>
      <p><span class="pill">3</span> In <b>Resources</b>, reduce a cap and see how schedule feasibility changes (even if δ=0).</p>
    </details>

    <div class="row">
      <label class="muted" for="presetSel">Preset</label>
      <select id="presetSel">
        <option value="basic">Glueable baseline (example)</option>
        <option value="patchConflict">Patch conflict (δ&gt;0)</option>
        <option value="resourceCrunch">Resource crunch (δ=0 but infeasible)</option>
      </select>
      <button class="accent" id="btnLoadPreset">Load</button>
      <button class="ghost" id="btnResetEdits" title="Revert to the last loaded preset">Reset edits</button>
      <button class="warn" id="btnExport">Export JSON</button>
      <button class="danger" id="btnClear">Clear</button>
    </div>

    <div class="row">
      <button id="btnCompute" class="accent">Compute</button>
      <label class="muted"><input type="checkbox" id="autoCompute"> Auto-compute</label>
      <span class="pill">Pin mode:</span>
      <select id="pinMode">
        <option value="soft">Soft (pins nudge earliest start)</option>
        <option value="hard">Hard (pins act as constraints)</option>
      </select>
      <span class="pill">Risk smoothing:</span>
      <input id="smoothRounds" type="range" min="0" max="10" value="2">
      <span id="smoothLabel" class="pill">2</span>
    </div>

    <div class="kpis">
      <div class="kpi">
        <b>Global section</b>
        <div id="globalSec" class="status-warn">—</div>
        <div class="muted" style="font-size:11px; margin-top:4px">“Exists” means: δ=0 on overlaps <i>and</i> schedule meets windows/resources.</div>
      </div>
      <div class="kpi">
        <b>Obstruction energy δ</b>
        <div id="obstruction">—</div>
        <div class="muted" style="font-size:11px; margin-top:4px">We sum sup-norm disagreements over overlapping patch pairs.</div>
      </div>
      <div class="kpi">
        <b>Diagnostics</b>
        <div id="diagnosticKpi">—</div>
        <div class="muted" style="font-size:11px; margin-top:4px">Slack + smoothed risk + constraint warnings.</div>
      </div>
    </div>

    <div id="toast" class="toast"></div>

    <div class="tabs" role="tablist" aria-label="Editor tabs">
      <button class="tab-btn active" data-tab="tasks">Tasks</button>
      <button class="tab-btn" data-tab="edges">Dependencies</button>
      <button class="tab-btn" data-tab="patches">Patches</button>
      <button class="tab-btn" data-tab="resources">Resources</button>
      <button class="tab-btn" data-tab="json">Raw JSON</button>
    </div>

    <div id="panel_tasks" class="tab-panel active" role="tabpanel">
      <div class="row tight">
        <button class="btn-xs ok-outline" id="btnAddTask">+ Add task</button>
        <span class="muted">Tip: Click a node on the right to inspect it.</span>
      </div>
      <div id="tasksTable"></div>
      <details class="callout">
        <summary><b>Task fields explained</b></summary>
        <p><b>Window</b> is [earliest start, latest end]. We mark a miss if (start &lt; window[0]) or (end &gt; window[1]).</p>
        <p><b>Risk</b> is just a scalar field on vertices; we smooth it by averaging over neighbors for a chosen number of rounds.</p>
        <p><b>Resources</b> are per-time-step capacities. This prototype uses discrete time and unit capacities by default.</p>
      </details>
    </div>

    <div id="panel_edges" class="tab-panel" role="tabpanel">
      <div class="row tight">
        <button class="btn-xs ok-outline" id="btnAddEdge">+ Add dependency</button>
        <span class="muted">Dependencies are directed edges u → v (u must finish before v starts).</span>
      </div>
      <div id="edgesTable"></div>
      <details class="callout">
        <summary><b>Why topology matters here</b></summary>
        <p>
          The sheaf story is happiest on a DAG: local-to-global questions are well-behaved, and scheduling can be done in a topological order.
          If you add a cycle, we still draw it, but “earliest start” becomes underdetermined (and the topo-sort warns).
        </p>
      </details>
    </div>

    <div id="panel_patches" class="tab-panel" role="tabpanel">
      <div class="row tight">
        <button class="btn-xs ok-outline" id="btnAddPatch">+ Add patch</button>
        <span class="muted">A patch pins some task start-times (soft or hard, depending on pin mode).</span>
      </div>
      <div id="patchesWrap"></div>
      <div class="callout warn">
        <b>Interpretation note.</b>
        <div class="muted" style="margin-top:6px">
          In an actual sheaf, restriction maps must satisfy identities on triple overlaps.
          Here we only measure pairwise disagreements; it’s closer to a “consistency energy” than a full cocycle condition.
        </div>
      </div>
    </div>

    <div id="panel_resources" class="tab-panel" role="tabpanel">
      <div class="row tight">
        <button class="btn-xs ok-outline" id="btnAddResource">+ Add resource type</button>
        <span class="muted">Caps apply globally at each discrete time step.</span>
      </div>
      <div id="resourcesTable"></div>
      <details class="callout">
        <summary><b>Resource model caveat</b></summary>
        <p>
          This is a coarse “per time-step” capacity check. Many real schedulers use cumulative constraints, calendars, and non-integer time.
          Still, it’s enough to see how local consistency (δ=0) is <i>not</i> the same thing as global feasibility.
        </p>
      </details>
    </div>

    <div id="panel_json" class="tab-panel" role="tabpanel">
      <div class="row tight">
        <button class="btn-xs ok-outline" id="btnApplyJSON">Apply JSON → editor</button>
        <button class="btn-xs ghost" id="btnCopyJSON">Copy</button>
        <span class="muted">If you edit JSON directly, click “Apply”.</span>
      </div>
      <textarea id="jsonInput" spellcheck="false"></textarea>
      <div id="validationBox" class="callout bad" style="display:none">
        <b>Validation</b>
        <div id="validationList" class="mono" style="margin-top:6px; white-space:pre-wrap"></div>
      </div>
    </div>

    <div class="inspector" id="inspector">
      <b>Selected task</b>
      <div class="big" id="selTitle">—</div>
      <div id="selBody" class="mono">Click a task node or a Gantt bar to inspect.</div>
      <div class="hr"></div>
      <div class="muted" style="font-size:11px">
        Inspector shows: window slack, pins, smoothed risk, and which constraints were active in placement.
      </div>
    </div>

    <div style="height:16px"></div>
  </div>

  <!-- RIGHT: visualisations -->
  <div class="panel scroll">
    <h2>Graph view</h2>
    <div class="legend">
      <span><span class="box" style="background:#60a5fa"></span> Scheduled task</span>
      <span><span class="box" style="background:#ef4444"></span> Window miss / infeasible</span>
      <span><span class="box" style="background:#f59e0b"></span> Patch disagreement</span>
    </div>

    <div class="svgbg">
      <svg id="graph" aria-label="Dependency graph"></svg>
    </div>

    <h2 style="margin-top:14px">Gantt view</h2>
    <div class="svgbg">
      <svg id="gantt" aria-label="Gantt chart"></svg>
    </div>

    <h2 style="margin-top:14px">Overlap consistency δ on patches</h2>
    <div id="overlapTable"></div>

    <h2 style="margin-top:14px">Why not glue? (conflicts & misses)</h2>
    <div id="whyBox" class="callout bad" style="display:none"></div>

    <div style="height:16px"></div>
  </div>
</div>

<div id="tt" class="tooltip"></div>

<script>
/** ---------------------------
 *  Utilities
 *  --------------------------- */
const $ = sel => document.querySelector(sel);
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const deepCopy = obj => JSON.parse(JSON.stringify(obj));
const uniq = arr => [...new Set(arr)];
const nowMs = () => (typeof performance !== "undefined" ? performance.now() : Date.now());

function toast(msg, kind="ok"){
  const t = $("#toast");
  t.classList.add("show");
  t.style.background = kind==="bad" ? "rgba(239,68,68,.12)" : (kind==="warn" ? "rgba(245,158,11,.10)" : "rgba(34,197,94,.12)");
  t.style.borderColor = kind==="bad" ? "rgba(239,68,68,.35)" : (kind==="warn" ? "rgba(245,158,11,.25)" : "rgba(34,197,94,.35)");
  t.textContent = msg;
  setTimeout(()=>t.classList.remove("show"), 2600);
}

/** ---------------------------
 *  Presets
 *  --------------------------- */
const PRESETS = {
  basic: {
    "tasks":[
      {"id":"A","name":"Design","duration":3,"window":[0,6],"resources":{"analyst":1},"risk":0.30},
      {"id":"B","name":"Permits","duration":2,"window":[0,5],"resources":{"analyst":1},"risk":0.20},
      {"id":"C","name":"Build","duration":5,"window":[3,14],"resources":{"crew":1},"risk":0.50},
      {"id":"D","name":"Test","duration":3,"window":[9,20],"resources":{"crew":1},"risk":0.40}
    ],
    "edges":[["A","C"],["B","C"],["C","D"]],
    "resources":{"analyst":1,"crew":1},
    "local_patches":[
      {"name":"Planning","tasks":{"A":{"s":0},"B":{"s":1}}},
      {"name":"Integration","tasks":{"B":{"s":2},"C":{"s":6}}},
      {"name":"Delivery","tasks":{"C":{"s":4},"D":{"s":10}}}
    ],
    "cover":[["A","B"],["B","C"],["C","D"]]
  },
  patchConflict: {
    "tasks":[
      {"id":"A","name":"Design","duration":3,"window":[0,6],"resources":{"analyst":1},"risk":0.30},
      {"id":"B","name":"Permits","duration":2,"window":[0,5],"resources":{"analyst":1},"risk":0.20},
      {"id":"C","name":"Build","duration":5,"window":[3,14],"resources":{"crew":1},"risk":0.50},
      {"id":"D","name":"Test","duration":3,"window":[9,20],"resources":{"crew":1},"risk":0.40}
    ],
    "edges":[["A","C"],["B","C"],["C","D"]],
    "resources":{"analyst":1,"crew":1},
    "local_patches":[
      {"name":"Planning","tasks":{"A":{"s":0},"B":{"s":1}}},
      {"name":"Integration","tasks":{"B":{"s":4},"C":{"s":6}}},  // <-- conflicts with Planning on B
      {"name":"Delivery","tasks":{"C":{"s":4},"D":{"s":10}}}
    ],
    "cover":[["A","B"],["B","C"],["C","D"]]
  },
  resourceCrunch: {
    "tasks":[
      {"id":"A","name":"Design","duration":3,"window":[0,7],"resources":{"analyst":1},"risk":0.25},
      {"id":"B","name":"Permits","duration":3,"window":[0,7],"resources":{"analyst":1},"risk":0.20},
      {"id":"C","name":"Build","duration":5,"window":[3,14],"resources":{"crew":1},"risk":0.55},
      {"id":"D","name":"Test","duration":4,"window":[8,16],"resources":{"crew":1},"risk":0.45},
      {"id":"E","name":"Commission","duration":2,"window":[10,16],"resources":{"crew":1},"risk":0.35}
    ],
    "edges":[["A","C"],["B","C"],["C","D"],["D","E"]],
    "resources":{"analyst":1,"crew":1},
    "local_patches":[
      {"name":"Planning","tasks":{"A":{"s":0},"B":{"s":0}}},
      {"name":"Delivery","tasks":{"C":{"s":4},"D":{"s":9},"E":{"s":13}}}
    ],
    "cover":[["A","B"],["C","D","E"]]
  }
};

/** ---------------------------
 *  Global app state
 *  --------------------------- */
let STATE = null;            // editable model
let LOADED_SNAPSHOT = null;  // last loaded preset snapshot
let SELECTED_TASK = null;    // id string
let LAST_COMPUTE = null;     // {data,res,cons,meta}

let _autoComputeTimer = null;
function scheduleAutoCompute(){
  if(!$("#autoCompute").checked) return;
  if(_autoComputeTimer) clearTimeout(_autoComputeTimer);
  _autoComputeTimer = setTimeout(()=>compute(), 180);
}

/** ---------------------------
 *  Normalization + validation
 *  --------------------------- */
function normalizeData(input){
  const data = deepCopy(input || {});
  data.tasks = Array.isArray(data.tasks) ? data.tasks : [];
  data.edges = Array.isArray(data.edges) ? data.edges : [];
  data.resources = data.resources || {};
  data.local_patches = Array.isArray(data.local_patches) ? data.local_patches : [];
  data.cover = Array.isArray(data.cover) ? data.cover : [];

  // Normalize tasks
  for(const t of data.tasks){
    if(!t.id) t.id = "T" + Math.random().toString(16).slice(2,6).toUpperCase();
    t.name = t.name ?? t.id;
    t.duration = Math.max(1, Math.round(+t.duration || 1));
    if(!Array.isArray(t.window) || t.window.length!==2) t.window=[0,999];
    t.window = [Math.round(+t.window[0]||0), Math.round(+t.window[1]||0)];
    if(t.window[1] < t.window[0] + t.duration) t.window[1] = t.window[0] + t.duration;
    t.resources = t.resources || {};
    for(const k of Object.keys(t.resources)){
      t.resources[k] = Math.max(0, +t.resources[k] || 0);
    }
    t.risk = clamp(+t.risk || 0, 0, 1);
  }

  // Index tasks
  data.byId = {};
  for(const t of data.tasks) data.byId[t.id] = t;

  // preds / succs
  data.preds = {}; data.succs = {};
  for(const t of data.tasks){ data.preds[t.id]=[]; data.succs[t.id]=[]; }
  for(const e of data.edges){
    if(!Array.isArray(e) || e.length!==2) continue;
    const [u,v] = e;
    if(!(u in data.byId) || !(v in data.byId)) continue;
    data.succs[u].push(v);
    data.preds[v].push(u);
  }

  // Normalize patches
  for(const P of data.local_patches){
    P.name = P.name ?? "Patch";
    P.tasks = P.tasks || {};
    // drop non-existent task refs
    for(const k of Object.keys(P.tasks)){
      if(!(k in data.byId)) delete P.tasks[k];
      else {
        const s = P.tasks[k]?.s;
        P.tasks[k] = {s: (typeof s==="number" && isFinite(s)) ? Math.round(s) : 0};
      }
    }
  }

  return data;
}

function validateModel(data){
  const errs = [];
  const ids = data.tasks.map(t=>t.id);
  const dup = ids.filter((x,i)=>ids.indexOf(x)!==i);
  if(dup.length) errs.push("Duplicate task IDs: " + uniq(dup).join(", "));

  // edges validity + cycle check (soft)
  for(const [u,v] of data.edges){
    if(!(u in data.byId) || !(v in data.byId)) errs.push(`Edge refers to missing task: ${u} → ${v}`);
    if(u===v) errs.push(`Self-loop edge: ${u} → ${v}`);
  }

  // windows
  for(const t of data.tasks){
    if(t.window[1] < t.window[0] + t.duration) errs.push(`Window too tight for ${t.id}: [${t.window[0]},${t.window[1]}] with duration ${t.duration}`);
  }

  // unknown resource types used by tasks
  const knownRes = new Set(Object.keys(data.resources || {}));
  for(const t of data.tasks){
    for(const r of Object.keys(t.resources||{})){
      if(!knownRes.has(r)) errs.push(`Task ${t.id} uses resource "${r}" but no global cap is defined (treated as ∞).`);
    }
  }

  return errs;
}

/** ---------------------------
 *  Topology + scheduling
 *  --------------------------- */
function topoOrder(data){
  const indeg = {};
  for(const k of Object.keys(data.preds)) indeg[k] = data.preds[k].length;
  const q = [];
  for(const k of Object.keys(indeg)) if(indeg[k]===0) q.push(k);
  const order = [];
  while(q.length){
    const u = q.shift();
    order.push(u);
    for(const v of data.succs[u]){
      indeg[v]--;
      if(indeg[v]===0) q.push(v);
    }
  }
  if(order.length !== data.tasks.length){
    // cycle or disconnected weirdness
    const missing = data.tasks.map(t=>t.id).filter(id=>!order.includes(id));
    // Put missing at end to keep deterministic behaviour.
    return order.concat(missing);
  }
  return order;
}

function collectPinnedTimes(data){
  const pins = {}; // id -> array of pinned starts (integers)
  if(!Array.isArray(data.local_patches)) return pins;
  for(const P of data.local_patches){
    if(!P.tasks) continue;
    for(const id of Object.keys(P.tasks)){
      const s = P.tasks[id]?.s;
      if(typeof s !== "number" || !isFinite(s)) continue;
      if(!pins[id]) pins[id] = [];
      pins[id].push(Math.round(s));
    }
  }
  return pins;
}

function computeSchedule(data, opts){
  const pinMode = (opts && opts.pinMode) || "soft";
  const pins = collectPinnedTimes(data);

  // horizon heuristic
  const horizon = data.tasks.reduce((acc,t)=>acc + t.duration, 0) + 20;

  const resCaps = data.resources || {};
  const resUse = {};
  for(const r of Object.keys(resCaps)){
    resUse[r] = new Array(horizon).fill(0);
  }

  const sched = {};
  const feasibility = {};
  const details = {};

  const order = topoOrder(data);
  const unknownRes = new Set();

  for(const id of order){
    const t = data.byId[id];
    if(!t) continue;

    let est = t.window[0];
    if(data.preds[id].length){
      est = Math.max(est, ...data.preds[id].map(p => (sched[p] ?? 0) + data.byId[p].duration));
    }

    let lb = est;
    let ub = t.window[1] - t.duration;

    const myPins = (pins[id] || []).slice();
    let hardConflict = false;
    let pinConstraint = null;

    if(myPins.length){
      const pmin = Math.min(...myPins);
      const pmax = Math.max(...myPins);

      if(pinMode === "soft"){
        // soft = nudge earliest feasible start upwards
        lb = Math.max(lb, pmax);
        pinConstraint = {kind:"soft", pmin, pmax};
      } else {
        // hard = must equal a pinned value; if multiple disagree, no solution
        if(pmin !== pmax) hardConflict = true;
        lb = Math.max(lb, pmax);
        ub = Math.min(ub, pmin);
        pinConstraint = {kind:"hard", pmin, pmax};
      }
    }

    // If ub < lb, we can't satisfy the window/pins; we'll still place at lb to visualize.
    const ubOriginal = ub;
    if(ub < lb) ub = lb;

    // Try to find a resource-feasible start in [lb, ub]
    let placed = false;
    let reason = "ok";
    let tryCount = 0;

    for(let s=lb; s<=ub; s++){
      tryCount++;
      let ok = true;
      for(let tau=s; tau<s+t.duration; tau++){
        for(const r of Object.keys(t.resources||{})){
          const need = t.resources[r] || 0;
          if(need <= 0) continue;
          const cap = (r in resCaps) ? resCaps[r] : Infinity;
          if(!(r in resCaps)) unknownRes.add(r);
          const used = (r in resUse) ? resUse[r][tau] : 0;
          if(used + need > cap){ ok = false; break; }
        }
        if(!ok) break;
      }
      if(ok){
        sched[id] = s;
        // record resource usage only for known resources (others are treated as ∞)
        for(let tau=s; tau<s+t.duration; tau++){
          for(const r of Object.keys(t.resources||{})){
            const need = t.resources[r] || 0;
            if(need <= 0) continue;
            if(r in resUse) resUse[r][tau] += need;
          }
        }
        placed = true;
        break;
      }
    }

    if(!placed){
      // fallback
      sched[id] = lb;
      if(pinMode==="hard" && myPins.length) reason = "pin/window infeasible";
      else if(ubOriginal < lb) reason = "window too tight";
      else reason = "resource bottleneck";
    }

    const s = sched[id];
    const e = s + t.duration;
    const okWindow = (s >= t.window[0] && e <= t.window[1]);
    feasibility[id] = okWindow ? "ok" : "miss";
    details[id] = {
      id,
      est, lb, ubOriginal,
      s, e,
      duration: t.duration,
      window: t.window.slice(),
      slackEnd: t.window[1] - e,
      pins: myPins,
      hardConflict,
      pinConstraint,
      placed,
      tryCount,
      reason
    };
  }

  return {sched, feasibility, details, unknownRes:[...unknownRes]};
}

/** ---------------------------
 *  δ-overlaps + “why not glue”
 *  --------------------------- */
function overlapsConsistency(data){
  const out = [];
  let energy = 0;
  if(!data.local_patches || data.local_patches.length<=1) return {rows:out, energy:0, conflictTasks: new Set()};
  const Ps = data.local_patches;
  const conflictTasks = new Set();

  for(let i=0;i<Ps.length;i++){
    for(let j=i+1;j<Ps.length;j++){
      const Pi=Ps[i], Pj=Ps[j];
      const keys = new Set();
      if(Pi.tasks) Object.keys(Pi.tasks).forEach(k=>keys.add(k));
      if(Pj.tasks) Object.keys(Pj.tasks).forEach(k=>keys.add(k));
      const common=[...keys].filter(k=>Pi.tasks && Pj.tasks && (k in Pi.tasks) && (k in Pj.tasks));
      if(common.length){
        let sup = 0;
        const diffs = common.map(k=>{
          const di = Math.abs((Pi.tasks[k].s??NaN) - (Pj.tasks[k].s??NaN));
          if(di>0) conflictTasks.add(k);
          sup = Math.max(sup, di);
          return {k, di, si: Pi.tasks[k].s, sj: Pj.tasks[k].s};
        });
        energy += sup;
        out.push({Pi:Pi.name||("Patch "+i), Pj:Pj.name||("Patch "+j), sup, diffs});
      }
    }
  }
  return {rows:out, energy, conflictTasks};
}

function drawOverlapTable(cons){
  const wrap = $("#overlapTable");
  if(cons.rows.length===0){
    wrap.innerHTML = "<small class='muted'>No overlaps between local patches.</small>";
    return;
  }
  let html = "<table><thead><tr><th>Patch pair</th><th>Overlap tasks</th><th>δ∞ (sup)</th></tr></thead><tbody>";
  for(const r of cons.rows){
    const cells = r.diffs.map(d=>{
      const badge = d.di>0 ? "<span class='badge' style='border-color:rgba(245,158,11,.5); color:var(--warn)'>conflict</span>" : "<span class='badge'>ok</span>";
      return `<span class="mono">${d.k}: |${d.si}−${d.sj}|=${d.di}</span> ${badge}`;
    }).join("<br>");
    html += `<tr><td>${r.Pi} ↔ ${r.Pj}</td><td>${cells}</td><td>${r.sup}</td></tr>`;
  }
  html += "</tbody></table>";
  wrap.innerHTML = html;
}

function buildWhyBox(data, res, cons){
  const box = $("#whyBox");
  const misses = data.tasks.filter(t=>res.feasibility[t.id]==="miss");
  const conflicts = [...cons.conflictTasks];

  const unknownRes = res.unknownRes || [];
  const msgs = [];

  if(cons.energy > 0){
    msgs.push(`<div><b>Patch disagreements (δ&gt;0)</b><div class="muted" style="margin-top:6px">At least one overlap assigns different starts to the same task. These are “obstructions” to gluing.</div></div>`);
    msgs.push(`<div class="mono" style="margin-top:6px">${conflicts.map(k=>`• ${k} appears with multiple pinned starts`).join("<br>")}</div>`);
  } else {
    msgs.push(`<div><b>Patch layer is consistent (δ=0)</b><div class="muted" style="margin-top:6px">Local pinned starts agree on overlaps (as far as this toy δ checks).</div></div>`);
  }

  if(misses.length){
    msgs.push(`<div style="margin-top:10px"><b>Schedule window misses</b><div class="muted" style="margin-top:6px">Even with δ=0, precedence/resources/windows may prevent feasibility.</div></div>`);
    msgs.push(`<div class="mono" style="margin-top:6px">${misses.map(t=>{
      const d = res.details[t.id];
      return `• ${t.id}: end slack=${d.slackEnd} (reason: ${d.reason})`;
    }).join("<br>")}</div>`);
  }

  if(unknownRes.length){
    msgs.push(`<div style="margin-top:10px"><b>Resource warnings</b><div class="muted" style="margin-top:6px">These resource types are used by tasks but have no global caps (treated as ∞):</div></div>`);
    msgs.push(`<div class="mono" style="margin-top:6px">${unknownRes.map(r=>`• ${r}`).join("<br>")}</div>`);
  }

  const show = (cons.energy>0) || misses.length || unknownRes.length;
  box.style.display = show ? "block" : "none";
  if(show){
    box.className = "callout " + ((cons.energy>0 || misses.length) ? "bad" : "warn");
    box.innerHTML = msgs.join("<div class='hr'></div>");
  }
}

/** ---------------------------
 *  Risk smoothing metric
 *  --------------------------- */
function smoothRisk(data, rounds){
  const risk = {};
  for(const t of data.tasks) risk[t.id] = t.risk || 0;
  for(let r=0;r<rounds;r++){
    const nr = {};
    for(const t of data.tasks){
      const nbrs = new Set([...(data.preds[t.id]||[]), ...(data.succs[t.id]||[])]);
      const vals = [risk[t.id], ...[...nbrs].map(k=>risk[k] ?? 0)];
      nr[t.id] = vals.reduce((a,b)=>a+b,0) / vals.length;
    }
    Object.assign(risk, nr);
  }
  const avg = data.tasks.reduce((a,t)=>a + (risk[t.id]||0), 0) / Math.max(1, data.tasks.length);
  return {risk, avg};
}

/** ---------------------------
 *  Layout + drawing
 *  --------------------------- */
function rankLayout(data){
  // rank by longest-path distance from sources (using topo order)
  const order = topoOrder(data);
  const dist = {};
  for(const id of order) dist[id] = 0;
  for(const u of order){
    for(const v of (data.succs[u]||[])) dist[v] = Math.max(dist[v], dist[u] + 1);
  }
  const byRank = {};
  for(const id of order){
    const r = dist[id];
    if(!byRank[r]) byRank[r] = [];
    byRank[r].push(id);
  }
  const ranks = Object.keys(byRank).map(Number).sort((a,b)=>a-b);
  const pos = {};
  const dx = 170, dy = 74, margin = 24;

  ranks.forEach((r, i)=>{
    byRank[r].forEach((id, j)=>{
      pos[id] = {x: margin + i*dx, y: margin + j*dy};
    });
  });
  return pos;
}

function showTooltip(html, x, y){
  const tt = $("#tt");
  tt.innerHTML = html;
  tt.style.left = (x + 12) + "px";
  tt.style.top  = (y + 12) + "px";
  tt.style.display = "block";
}
function hideTooltip(){ $("#tt").style.display = "none"; }

function drawGraph(data, res, cons, smoothed){
  const svg = $("#graph");
  svg.innerHTML = "";
  const pos = rankLayout(data);

  // edges
  for(const [u,v] of data.edges){
    if(!(u in pos) || !(v in pos)) continue;
    const a = pos[u], b = pos[v];
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1",a.x+120); line.setAttribute("y1",a.y+20);
    line.setAttribute("x2",b.x+0);   line.setAttribute("y2",b.y+20);
    line.setAttribute("stroke","#374151"); line.setAttribute("stroke-width","2");
    svg.appendChild(line);

    const arr = document.createElementNS("http://www.w3.org/2000/svg","polygon");
    const ax=b.x-2, ay=b.y+20, s=6;
    arr.setAttribute("points", `${ax},${ay} ${ax-s},${ay-s} ${ax-s},${ay+s}`);
    arr.setAttribute("fill","#374151");
    svg.appendChild(arr);
  }

  // nodes
  for(const t of data.tasks){
    const p = pos[t.id] || {x:24, y:24};
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("data-id", t.id);
    g.style.cursor = "pointer";

    const okWindow = (res.feasibility[t.id]==="ok");
    const isConflict = cons.conflictTasks.has(t.id);
    const isSel = (SELECTED_TASK === t.id);

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x",p.x); rect.setAttribute("y",p.y);
    rect.setAttribute("rx",10); rect.setAttribute("ry",10);
    rect.setAttribute("width",140); rect.setAttribute("height",44);
    rect.setAttribute("fill", okWindow ? "#60a5fa" : "#ef4444");
    rect.setAttribute("stroke", isSel ? "#e5e7eb" : (isConflict ? "#f59e0b" : "#0b1220"));
    rect.setAttribute("stroke-width", isSel ? "3" : (isConflict ? "3" : "2"));
    g.appendChild(rect);

    const title = document.createElementNS("http://www.w3.org/2000/svg","text");
    title.setAttribute("x", p.x+10); title.setAttribute("y", p.y+16);
    title.setAttribute("fill", "#041b0f");
    title.setAttribute("font-size","12");
    title.setAttribute("font-weight","800");
    title.textContent = `${t.name} (${t.id})`;
    g.appendChild(title);

    const d = res.details[t.id];
    const s = res.sched[t.id];
    const e = s + t.duration;
    const rsk = smoothed?.risk?.[t.id];

    const sub = document.createElementNS("http://www.w3.org/2000/svg","text");
    sub.setAttribute("x", p.x+10); sub.setAttribute("y", p.y+34);
    sub.setAttribute("fill", "#041b0f");
    sub.setAttribute("font-size","11");
    sub.textContent = `s=${s}, e=${e} | slack=${d.slackEnd}`;
    g.appendChild(sub);

    svg.appendChild(g);
  }

  // interactivity
  svg.querySelectorAll("g[data-id]").forEach(g=>{
    const id = g.getAttribute("data-id");
    g.addEventListener("mouseenter", ev=>{
      const t = data.byId[id];
      const d = res.details[id];
      const pins = (d.pins||[]);
      const pinText = pins.length ? `pins: [${pins.join(", ")}]` : "pins: —";
      const rsk = smoothed?.risk?.[id];
      const html = `
        <div><b>${t.name} (${t.id})</b></div>
        <div class="mono" style="margin-top:4px">window=[${t.window[0]},${t.window[1]}], d=${t.duration}</div>
        <div class="mono">${pinText}</div>
        <div class="mono">est=${d.est}, chosen s=${d.s}, reason=${d.reason}</div>
        <div class="mono">smoothed risk ≈ ${rsk!=null ? rsk.toFixed(3) : "—"}</div>
      `;
      showTooltip(html, ev.clientX, ev.clientY);
    });
    g.addEventListener("mousemove", ev=>{
      const tt = $("#tt"); if(tt.style.display==="block"){
        tt.style.left = (ev.clientX + 12) + "px";
        tt.style.top  = (ev.clientY + 12) + "px";
      }
    });
    g.addEventListener("mouseleave", hideTooltip);
    g.addEventListener("click", ()=>{
      SELECTED_TASK = id;
      renderInspector();
      // re-draw for highlight
      drawGraph(data, res, cons, smoothed);
      drawGantt(data, res, cons, smoothed);
    });
  });
}

function drawGantt(data, res, cons, smoothed){
  const svg = $("#gantt");
  svg.innerHTML = "";

  const margin = {l:120, t:26, r:14, b:22};
  const W = svg.clientWidth || 900;

  let T = 0;
  for(const id in res.sched){
    const t = data.byId[id];
    T = Math.max(T, res.sched[id] + (t?.duration||1));
  }
  T = Math.max(T, 20);

  const rowH = 24;
  const maxY = data.tasks.length * rowH + margin.t + margin.b;
  svg.setAttribute("height", maxY);

  // time grid
  for(let x=0;x<=T;x++){
    const X = margin.l + (W - margin.l - margin.r) * x / T;
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1",X); line.setAttribute("x2",X);
    line.setAttribute("y1",margin.t); line.setAttribute("y2",maxY-margin.b);
    line.setAttribute("stroke", x%5===0 ? "#374151" : "#1f2937");
    line.setAttribute("stroke-width", x%5===0 ? "1.5" : "1");
    svg.appendChild(line);

    if(x%5===0){
      const tx = document.createElementNS("http://www.w3.org/2000/svg","text");
      tx.setAttribute("x", X-4);
      tx.setAttribute("y", 16);
      tx.setAttribute("fill","#9ca3af");
      tx.setAttribute("font-size","10");
      tx.textContent = x;
      svg.appendChild(tx);
    }
  }

  // rows
  data.tasks.forEach((t,i)=>{
    const d = res.details[t.id];
    const y = margin.t + 4 + i*rowH;

    // window band (light)
    const W0 = t.window[0];
    const W1 = t.window[1];
    const X0 = margin.l + (W - margin.l - margin.r) * W0 / T;
    const X1 = margin.l + (W - margin.l - margin.r) * W1 / T;
    const band = document.createElementNS("http://www.w3.org/2000/svg","rect");
    band.setAttribute("x", X0);
    band.setAttribute("y", y);
    band.setAttribute("width", Math.max(2, X1-X0));
    band.setAttribute("height", 16);
    band.setAttribute("fill", "rgba(156,163,175,.18)");
    band.setAttribute("stroke", "rgba(156,163,175,.10)");
    band.setAttribute("stroke-width", "1");
    svg.appendChild(band);

    // scheduled bar
    const s = res.sched[t.id];
    const e = s + t.duration;
    const Xs = margin.l + (W - margin.l - margin.r) * s / T;
    const Xe = margin.l + (W - margin.l - margin.r) * e / T;

    const ok = (res.feasibility[t.id]==="ok");
    const isConflict = cons.conflictTasks.has(t.id);
    const isSel = (SELECTED_TASK === t.id);

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", Xs);
    rect.setAttribute("y", y);
    rect.setAttribute("width", Math.max(2, Xe-Xs));
    rect.setAttribute("height", 16);
    rect.setAttribute("fill", ok ? "#60a5fa" : "#ef4444");
    rect.setAttribute("stroke", isSel ? "#e5e7eb" : (isConflict ? "#f59e0b" : "#0b1220"));
    rect.setAttribute("stroke-width", isSel ? "3" : (isConflict ? "3" : "1.5"));
    rect.setAttribute("rx","6"); rect.setAttribute("ry","6");
    rect.setAttribute("data-id", t.id);
    rect.style.cursor = "pointer";
    svg.appendChild(rect);

    // label (left)
    const lab = document.createElementNS("http://www.w3.org/2000/svg","text");
    lab.setAttribute("x", 8);
    lab.setAttribute("y", y+12);
    lab.setAttribute("fill", "#e5e7eb");
    lab.setAttribute("font-size","11");
    lab.textContent = `${t.id} (${t.name})`;
    svg.appendChild(lab);

    // right mini label
    const mini = document.createElementNS("http://www.w3.org/2000/svg","text");
    mini.setAttribute("x", Xe + 6);
    mini.setAttribute("y", y+12);
    mini.setAttribute("fill", "#9ca3af");
    mini.setAttribute("font-size","10");
    const rsk = smoothed?.risk?.[t.id];
    mini.textContent = `slack=${d.slackEnd}, r≈${rsk!=null ? rsk.toFixed(2) : "—"}`;
    svg.appendChild(mini);
  });

  // interactivity for gantt bars
  svg.querySelectorAll("rect[data-id]").forEach(r=>{
    const id = r.getAttribute("data-id");
    r.addEventListener("mouseenter", ev=>{
      const t = data.byId[id];
      const d = res.details[id];
      const rsk = smoothed?.risk?.[id];
      const html = `
        <div><b>${t.name} (${id})</b></div>
        <div class="mono" style="margin-top:4px">window=[${t.window[0]},${t.window[1]}], d=${t.duration}</div>
        <div class="mono">scheduled: s=${d.s}, e=${d.e} (slack=${d.slackEnd})</div>
        <div class="mono">reason: ${d.reason}</div>
        <div class="mono">smoothed risk ≈ ${rsk!=null ? rsk.toFixed(3) : "—"}</div>
      `;
      showTooltip(html, ev.clientX, ev.clientY);
    });
    r.addEventListener("mousemove", ev=>{
      const tt = $("#tt"); if(tt.style.display==="block"){
        tt.style.left = (ev.clientX + 12) + "px";
        tt.style.top  = (ev.clientY + 12) + "px";
      }
    });
    r.addEventListener("mouseleave", hideTooltip);
    r.addEventListener("click", ()=>{
      SELECTED_TASK = id;
      renderInspector();
      drawGraph(data, res, cons, smoothed);
      drawGantt(data, res, cons, smoothed);
    });
  });
}

/** ---------------------------
 *  Inspector
 *  --------------------------- */
function renderInspector(){
  const boxTitle = $("#selTitle");
  const boxBody = $("#selBody");

  if(!SELECTED_TASK || !LAST_COMPUTE || !(SELECTED_TASK in LAST_COMPUTE.data.byId)){
    boxTitle.textContent = "—";
    boxBody.textContent = "Click a task node or a Gantt bar to inspect.";
    return;
  }
  const {data,res,cons,smoothed} = LAST_COMPUTE;
  const t = data.byId[SELECTED_TASK];
  const d = res.details[SELECTED_TASK];
  const pins = (d.pins||[]);
  const pinMode = $("#pinMode").value;

  const resPairs = Object.keys(t.resources||{}).filter(k=>(t.resources[k]||0)>0).map(k=>`${k}:${t.resources[k]}`).join(", ");
  const resTxt = resPairs.length ? resPairs : "—";
  const riskTxt = (smoothed?.risk?.[t.id] != null) ? smoothed.risk[t.id].toFixed(3) : "—";
  const conflict = cons.conflictTasks.has(t.id) ? "yes" : "no";

  boxTitle.textContent = `${t.name} (${t.id})`;
  boxBody.innerHTML = `
    <div><b class="muted">Schedule</b><div class="mono">est=${d.est}, chosen start s=${d.s}, end e=${d.e}, reason=${d.reason}</div></div>
    <div style="margin-top:6px"><b class="muted">Window</b><div class="mono">[${t.window[0]}, ${t.window[1]}], duration=${t.duration}, end-slack=${d.slackEnd}</div></div>
    <div style="margin-top:6px"><b class="muted">Patch pins</b>
      <div class="mono">${pins.length ? ("mode="+pinMode+", pins=["+pins.join(", ")+"]"+(d.hardConflict ? " (conflict)" : "")) : "—"}</div>
    </div>
    <div style="margin-top:6px"><b class="muted">Resources</b><div class="mono">${resTxt}</div></div>
    <div style="margin-top:6px"><b class="muted">Smoothed risk</b><div class="mono">${riskTxt}</div></div>
    <div style="margin-top:6px"><b class="muted">Patch disagreement?</b><div class="mono">${conflict}</div></div>
  `;
}

/** ---------------------------
 *  Editor rendering + handlers
 *  --------------------------- */
function setStateFromPreset(key){
  const obj = deepCopy(PRESETS[key] || PRESETS.basic);
  STATE = normalizeData(obj);
  LOADED_SNAPSHOT = deepCopy(STATE);
  SELECTED_TASK = null;
  syncJsonFromState();
  renderEditor();
  compute();
  toast("Loaded preset: " + key, "ok");
}

function resetEdits(){
  if(!LOADED_SNAPSHOT){ toast("Nothing to reset.", "warn"); return; }
  STATE = normalizeData(deepCopy(LOADED_SNAPSHOT));
  SELECTED_TASK = null;
  syncJsonFromState();
  renderEditor();
  compute();
  toast("Reverted to last loaded preset.", "ok");
}

function clearAll(){
  STATE = normalizeData({tasks:[], edges:[], resources:{}, local_patches:[]});
  LOADED_SNAPSHOT = deepCopy(STATE);
  SELECTED_TASK = null;
  syncJsonFromState();
  renderEditor();
  compute();
  toast("Cleared model.", "warn");
}

function syncJsonFromState(){
  $("#jsonInput").value = JSON.stringify(stripInternal(STATE), null, 2);
}

function stripInternal(data){
  const d = deepCopy(data);
  delete d.byId; delete d.preds; delete d.succs;
  return d;
}

function applyJsonToState(){
  let obj = null;
  try{
    obj = JSON.parse($("#jsonInput").value);
  } catch(e){
    showValidation(["Invalid JSON: " + e.message]);
    toast("JSON parse error.", "bad");
    return;
  }
  STATE = normalizeData(obj);
  // applying JSON counts as a "load" for reset purposes
  LOADED_SNAPSHOT = deepCopy(STATE);
  renderEditor();
  compute();
  toast("Applied JSON → editor.", "ok");
}

function showValidation(errs){
  const box = $("#validationBox");
  const list = $("#validationList");
  if(!errs || !errs.length){
    box.style.display = "none";
    list.textContent = "";
    return;
  }
  box.style.display = "block";
  list.textContent = errs.map(e=>"• " + e).join("\n");
}

function renderTasksTable(){
  const wrap = $("#tasksTable");
  const resKeys = Object.keys(STATE.resources || {});
  const colsRes = resKeys.map(r=>`<th>${r}</th>`).join("");
  const rows = STATE.tasks.map((t, idx)=>{
    const resCells = resKeys.map(r=>{
      const val = (t.resources && t.resources[r] != null) ? t.resources[r] : 0;
      return `<td><input type="number" min="0" step="1" value="${val}" data-kind="task" data-index="${idx}" data-field="res:${r}"></td>`;
    }).join("");
    return `
      <tr>
        <td><input type="text" value="${t.id}" data-kind="task" data-index="${idx}" data-field="id" title="Task ID"></td>
        <td><input type="text" value="${escapeHtml(t.name)}" data-kind="task" data-index="${idx}" data-field="name" style="width:180px"></td>
        <td><input type="number" min="1" step="1" value="${t.duration}" data-kind="task" data-index="${idx}" data-field="duration"></td>
        <td><input type="number" step="1" value="${t.window[0]}" data-kind="task" data-index="${idx}" data-field="w0"></td>
        <td><input type="number" step="1" value="${t.window[1]}" data-kind="task" data-index="${idx}" data-field="w1"></td>
        <td>
          <div style="display:flex; gap:8px; align-items:center">
            <input type="range" min="0" max="1" step="0.01" value="${t.risk}" data-kind="task" data-index="${idx}" data-field="riskRange">
            <input type="number" min="0" max="1" step="0.01" value="${t.risk}" data-kind="task" data-index="${idx}" data-field="riskNum" style="width:72px">
          </div>
        </td>
        ${resCells}
        <td><button class="btn-xs danger-outline" data-kind="task" data-index="${idx}" data-action="delete">Remove</button></td>
      </tr>
    `;
  }).join("");

  wrap.innerHTML = `
    <div class="svgbg" style="padding:0">
      <div style="max-height: 320px; overflow:auto; border-radius:10px">
        <table>
          <thead>
            <tr>
              <th style="min-width:90px">ID</th>
              <th style="min-width:200px">Name</th>
              <th>dur</th>
              <th>w0</th>
              <th>w1</th>
              <th style="min-width:260px">risk</th>
              ${colsRes}
              <th></th>
            </tr>
          </thead>
          <tbody>${rows || `<tr><td colspan="${7+resKeys.length}" class="muted">No tasks. Add one.</td></tr>`}</tbody>
        </table>
      </div>
    </div>
  `;
}

function renderEdgesTable(){
  const wrap = $("#edgesTable");
  const ids = STATE.tasks.map(t=>t.id);
  const rows = STATE.edges.map((e, idx)=>{
    const u = e[0], v = e[1];
    return `
      <tr>
        <td>
          <select data-kind="edge" data-index="${idx}" data-field="u">
            ${ids.map(id=>`<option value="${id}" ${id===u?'selected':''}>${id}</option>`).join("")}
          </select>
        </td>
        <td>→</td>
        <td>
          <select data-kind="edge" data-index="${idx}" data-field="v">
            ${ids.map(id=>`<option value="${id}" ${id===v?'selected':''}>${id}</option>`).join("")}
          </select>
        </td>
        <td><button class="btn-xs danger-outline" data-kind="edge" data-index="${idx}" data-action="delete">Remove</button></td>
      </tr>
    `;
  }).join("");

  wrap.innerHTML = `
    <div class="svgbg" style="padding:0">
      <div style="max-height: 260px; overflow:auto; border-radius:10px">
        <table>
          <thead>
            <tr><th>from</th><th></th><th>to</th><th></th></tr>
          </thead>
          <tbody>
            ${rows || `<tr><td colspan="4" class="muted">No dependencies. Add one.</td></tr>`}
          </tbody>
        </table>
      </div>
    </div>
    <div class="muted" style="font-size:11px; margin-top:8px">
      The schedule uses a topological pass and greedily places tasks at the earliest resource-feasible time inside their window.
    </div>
  `;
}

function renderResourcesTable(){
  const wrap = $("#resourcesTable");
  const keys = Object.keys(STATE.resources || {});
  const rows = keys.map((r, idx)=>{
    const cap = STATE.resources[r];
    return `
      <tr>
        <td><input type="text" value="${r}" data-kind="res" data-index="${idx}" data-field="name"></td>
        <td><input type="number" min="0" step="1" value="${cap}" data-kind="res" data-index="${idx}" data-field="cap"></td>
        <td><button class="btn-xs danger-outline" data-kind="res" data-index="${idx}" data-action="delete">Remove</button></td>
      </tr>
    `;
  }).join("");

  wrap.innerHTML = `
    <div class="svgbg" style="padding:0">
      <div style="max-height: 260px; overflow:auto; border-radius:10px">
        <table>
          <thead><tr><th>resource</th><th>cap</th><th></th></tr></thead>
          <tbody>${rows || `<tr><td colspan="3" class="muted">No resources defined. Add one (e.g., analyst, crew).</td></tr>`}</tbody>
        </table>
      </div>
    </div>
    <div class="muted" style="font-size:11px; margin-top:8px">
      Any resource used by a task but missing here is treated as having infinite capacity (and flagged in diagnostics).
    </div>
  `;
}

function renderPatches(){
  const wrap = $("#patchesWrap");
  const ids = STATE.tasks.map(t=>t.id);

  const patchBlocks = STATE.local_patches.map((P, pIdx)=>{
    const entries = Object.keys(P.tasks||{}).sort().map((id, j)=>{
      const s = P.tasks[id]?.s ?? 0;
      return `
        <tr>
          <td>
            <select data-kind="patchEntry" data-patch="${pIdx}" data-entry="${j}" data-field="id">
              ${ids.map(tid=>`<option value="${tid}" ${tid===id?'selected':''}>${tid}</option>`).join("")}
            </select>
          </td>
          <td><input type="number" step="1" value="${s}" data-kind="patchEntry" data-patch="${pIdx}" data-entry="${j}" data-field="s"></td>
          <td><button class="btn-xs danger-outline" data-kind="patchEntry" data-patch="${pIdx}" data-entry="${j}" data-action="delete">Remove</button></td>
        </tr>
      `;
    }).join("");

    return `
      <details class="callout" open>
        <summary>
          <span style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
            <b>Patch</b>
            <input type="text" value="${escapeHtml(P.name)}" data-kind="patch" data-patch="${pIdx}" data-field="name" style="width:200px">
            <button class="btn-xs danger-outline" data-kind="patch" data-patch="${pIdx}" data-action="delete">Remove patch</button>
          </span>
        </summary>

        <div style="margin-top:8px">
          <div class="row tight">
            <button class="btn-xs ok-outline" data-kind="patch" data-patch="${pIdx}" data-action="addEntry">+ Pin task</button>
            <span class="muted">Pins apply to tasks listed here.</span>
          </div>

          <div class="svgbg" style="padding:0">
            <div style="max-height: 240px; overflow:auto; border-radius:10px">
              <table>
                <thead><tr><th>task</th><th>start s</th><th></th></tr></thead>
                <tbody>
                  ${entries || `<tr><td colspan="3" class="muted">No pinned tasks in this patch.</td></tr>`}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </details>
    `;
  }).join("");

  wrap.innerHTML = patchBlocks || `<div class="muted">No patches. Add one to model “local plans”.</div>`;
}

function renderEditor(){
  // ensure STATE is normalized before rendering
  STATE = normalizeData(STATE);
  renderTasksTable();
  renderEdgesTable();
  renderPatches();
  renderResourcesTable();
  syncJsonFromState();

  const errs = validateModel(STATE);
  showValidation(errs);
}

function escapeHtml(s){
  return String(s ?? "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
}

/** ---------------------------
 *  Editor event handling
 *  --------------------------- */
function renameEverywhere(oldId, newId){
  if(oldId === newId) return;
  // edges
  STATE.edges = STATE.edges.map(([u,v]) => [u===oldId?newId:u, v===oldId?newId:v]);
  // patches
  for(const P of STATE.local_patches){
    if(P.tasks && (oldId in P.tasks)){
      P.tasks[newId] = P.tasks[oldId];
      delete P.tasks[oldId];
    }
  }
  // cover
  if(Array.isArray(STATE.cover)){
    STATE.cover = STATE.cover.map(arr => Array.isArray(arr) ? arr.map(x => x===oldId?newId:x) : arr);
  }
}

function rebuildPatchTaskObject(P, entryList){
  const obj = {};
  for(const e of entryList){
    if(!e || !e.id) continue;
    obj[e.id] = {s: Math.round(+e.s || 0)};
  }
  P.tasks = obj;
}

function getPatchEntries(P){
  // deterministic ordering for stable indices
  return Object.keys(P.tasks||{}).sort().map(id => ({id, s: P.tasks[id]?.s ?? 0}));
}

document.addEventListener("input", ev=>{
  const el = ev.target;
  const kind = el.dataset.kind;
  if(!kind) return;

  if(kind === "task"){
    const idx = +el.dataset.index;
    const field = el.dataset.field;
    const t = STATE.tasks[idx];
    if(!t) return;

    if(field === "id"){
      const oldId = t.id;
      const newId = (el.value || "").trim();
      if(!newId) return;
      // only apply if unique
      if(STATE.tasks.some((x,i)=>i!==idx && x.id===newId)){
        // keep UI but show validation later
        return;
      }
      t.id = newId;
      renameEverywhere(oldId, newId);
      if(SELECTED_TASK === oldId) SELECTED_TASK = newId;
    } else if(field === "name"){
      t.name = el.value ?? "";
    } else if(field === "duration"){
      t.duration = Math.max(1, Math.round(+el.value || 1));
    } else if(field === "w0"){
      t.window[0] = Math.round(+el.value || 0);
    } else if(field === "w1"){
      t.window[1] = Math.round(+el.value || 0);
    } else if(field === "riskRange" || field === "riskNum"){
      const v = clamp(+el.value || 0, 0, 1);
      t.risk = v;
      // keep sliders + numbers in sync for this row
      // Find siblings within row
      const row = el.closest("tr");
      if(row){
        const r1 = row.querySelector('input[data-field="riskRange"]');
        const r2 = row.querySelector('input[data-field="riskNum"]');
        if(r1 && r1 !== el) r1.value = v;
        if(r2 && r2 !== el) r2.value = v;
      }
    } else if(field && field.startsWith("res:")){
      const r = field.split(":")[1];
      t.resources = t.resources || {};
      t.resources[r] = Math.max(0, Math.round(+el.value || 0));
    }

    // Fix window tightness if needed
    if(t.window[1] < t.window[0] + t.duration) t.window[1] = t.window[0] + t.duration;

    syncJsonFromState();
    showValidation(validateModel(normalizeData(STATE)));
    scheduleAutoCompute();
  }

  if(kind === "edge"){
    const idx = +el.dataset.index;
    const field = el.dataset.field;
    if(!STATE.edges[idx]) return;
    if(field === "u") STATE.edges[idx][0] = el.value;
    if(field === "v") STATE.edges[idx][1] = el.value;
    syncJsonFromState();
    showValidation(validateModel(normalizeData(STATE)));
    scheduleAutoCompute();
  }

  if(kind === "res"){
    // resources are keyed; we render in deterministic key order
    const keys = Object.keys(STATE.resources||{});
    const idx = +el.dataset.index;
    const field = el.dataset.field;
    const key = keys[idx];
    if(!key) return;

    if(field === "cap"){
      STATE.resources[key] = Math.max(0, Math.round(+el.value || 0));
    }
    if(field === "name"){
      const newKey = (el.value || "").trim();
      if(!newKey || newKey === key) return;
      if(newKey in STATE.resources) return;
      // move cap
      STATE.resources[newKey] = STATE.resources[key];
      delete STATE.resources[key];
      // rename in tasks resources
      for(const t of STATE.tasks){
        if(t.resources && (key in t.resources)){
          t.resources[newKey] = t.resources[key];
          delete t.resources[key];
        }
      }
    }

    renderEditor(); // keys order changed; re-render
    scheduleAutoCompute();
  }

  if(kind === "patch"){
    const pIdx = +el.dataset.patch;
    const P = STATE.local_patches[pIdx];
    if(!P) return;
    if(el.dataset.field === "name"){
      P.name = el.value ?? "Patch";
      syncJsonFromState();
      scheduleAutoCompute();
    }
  }

  if(kind === "patchEntry"){
    const pIdx = +el.dataset.patch;
    const entryIdx = +el.dataset.entry;
    const P = STATE.local_patches[pIdx];
    if(!P) return;
    const entries = getPatchEntries(P);
    const ent = entries[entryIdx];
    if(!ent) return;

    if(el.dataset.field === "id"){
      ent.id = el.value;
    }
    if(el.dataset.field === "s"){
      ent.s = Math.round(+el.value || 0);
    }
    rebuildPatchTaskObject(P, entries);
    syncJsonFromState();
    scheduleAutoCompute();
  }
});

document.addEventListener("click", ev=>{
  const el = ev.target;
  const kind = el.dataset.kind;
  const action = el.dataset.action;

  if(el.id === "btnAddTask"){
    const base = "T";
    let k = 1;
    const ids = new Set(STATE.tasks.map(t=>t.id));
    while(ids.has(base + k)) k++;
    STATE.tasks.push({id: base+k, name: "Task "+k, duration: 2, window:[0,10], resources:{}, risk:0.3});
    renderEditor();
    scheduleAutoCompute();
    return;
  }
  if(el.id === "btnAddEdge"){
    const ids = STATE.tasks.map(t=>t.id);
    if(ids.length < 2){ toast("Need at least two tasks.", "warn"); return; }
    STATE.edges.push([ids[0], ids[1]]);
    renderEditor();
    scheduleAutoCompute();
    return;
  }
  if(el.id === "btnAddPatch"){
    STATE.local_patches.push({name:"New patch", tasks:{}});
    renderEditor();
    scheduleAutoCompute();
    return;
  }
  if(el.id === "btnAddResource"){
    const base = "res";
    let k=1;
    while((base+k) in STATE.resources) k++;
    STATE.resources[base+k] = 1;
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  // table row deletes
  if(kind === "task" && action === "delete"){
    const idx = +el.dataset.index;
    const oldId = STATE.tasks[idx]?.id;
    STATE.tasks.splice(idx, 1);
    // remove edges that reference missing tasks
    const ids = new Set(STATE.tasks.map(t=>t.id));
    STATE.edges = STATE.edges.filter(([u,v]) => ids.has(u) && ids.has(v));
    // remove patch entries
    for(const P of STATE.local_patches){
      if(P.tasks && oldId in P.tasks) delete P.tasks[oldId];
    }
    if(SELECTED_TASK === oldId) SELECTED_TASK = null;
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  if(kind === "edge" && action === "delete"){
    const idx = +el.dataset.index;
    STATE.edges.splice(idx, 1);
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  if(kind === "patch" && action === "delete"){
    const pIdx = +el.dataset.patch;
    STATE.local_patches.splice(pIdx, 1);
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  if(kind === "patch" && action === "addEntry"){
    const pIdx = +el.dataset.patch;
    const P = STATE.local_patches[pIdx];
    if(!P) return;
    const ids = STATE.tasks.map(t=>t.id);
    if(!ids.length){ toast("Add tasks first.", "warn"); return; }
    // add first task not already pinned
    const pinned = new Set(Object.keys(P.tasks||{}));
    const id = ids.find(x=>!pinned.has(x)) || ids[0];
    P.tasks[id] = {s: 0};
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  if(kind === "patchEntry" && action === "delete"){
    const pIdx = +el.dataset.patch;
    const entryIdx = +el.dataset.entry;
    const P = STATE.local_patches[pIdx];
    if(!P) return;
    const entries = getPatchEntries(P);
    entries.splice(entryIdx, 1);
    rebuildPatchTaskObject(P, entries);
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  if(kind === "res" && action === "delete"){
    const keys = Object.keys(STATE.resources||{});
    const idx = +el.dataset.index;
    const key = keys[idx];
    if(!key) return;
    delete STATE.resources[key];
    // drop that resource from tasks
    for(const t of STATE.tasks){
      if(t.resources && (key in t.resources)) delete t.resources[key];
    }
    renderEditor();
    scheduleAutoCompute();
    return;
  }

  // top buttons
  if(el.id === "btnLoadPreset"){
    setStateFromPreset($("#presetSel").value);
  }
  if(el.id === "btnResetEdits"){
    resetEdits();
  }
  if(el.id === "btnClear"){
    clearAll();
  }
  if(el.id === "btnCompute"){
    compute();
  }
  if(el.id === "btnExport"){
    exportJSON();
  }
  if(el.id === "btnApplyJSON"){
    applyJsonToState();
  }
  if(el.id === "btnCopyJSON"){
    navigator.clipboard?.writeText($("#jsonInput").value);
    toast("JSON copied.", "ok");
  }
});

/** ---------------------------
 *  Tabs
 *  --------------------------- */
document.addEventListener("click", ev=>{
  const b = ev.target.closest(".tab-btn");
  if(!b) return;
  const tab = b.dataset.tab;
  document.querySelectorAll(".tab-btn").forEach(x=>x.classList.toggle("active", x===b));
  document.querySelectorAll(".tab-panel").forEach(p=>{
    p.classList.toggle("active", p.id === "panel_" + tab);
  });
});

/** ---------------------------
 *  Smoothing slider
 *  --------------------------- */
$("#smoothRounds").addEventListener("input", ev=>{
  $("#smoothLabel").textContent = ev.target.value;
  scheduleAutoCompute();
});
$("#pinMode").addEventListener("change", scheduleAutoCompute);
$("#autoCompute").addEventListener("change", ()=>{
  if($("#autoCompute").checked) compute();
});

/** ---------------------------
 *  Export
 *  --------------------------- */
function exportJSON(){
  const blob = new Blob([$("#jsonInput").value], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "wbs.json";
  a.click();
}

/** ---------------------------
 *  Compute pipeline
 *  --------------------------- */
function compute(){
  const t0 = nowMs();
  // normalize + validate
  const data = normalizeData(STATE);
  const errs = validateModel(data);
  showValidation(errs);

  const res = computeSchedule(data, {pinMode: $("#pinMode").value});
  const cons = overlapsConsistency(data);

  const rounds = parseInt($("#smoothRounds").value, 10) || 0;
  const smoothed = smoothRisk(data, rounds);

  // KPIs
  $("#obstruction").textContent = cons.energy.toFixed(2);
  const misses = Object.values(res.feasibility).filter(x=>x==="miss").length;
  const conflictCount = cons.conflictTasks.size;

  const feasible = (misses===0) && (cons.energy===0) && (!errs.length);
  $("#globalSec").textContent = feasible ? "Exists (δ=0 & feasible)" : "Not yet (resolve conflicts)";
  $("#globalSec").className = feasible ? "status-ok" : ((cons.energy===0 && misses===0 && !errs.length) ? "status-warn" : "status-bad");

  // diagnostics text
  const minSlack = data.tasks.length ? Math.min(...data.tasks.map(t=>res.details[t.id].slackEnd)) : 0;
  $("#diagnosticKpi").textContent = `min end-slack=${minSlack} | avg smoothed risk=${smoothed.avg.toFixed(3)} | misses=${misses}, conflicts=${conflictCount}`;

  // visuals
  drawGraph(data, res, cons, smoothed);
  drawGantt(data, res, cons, smoothed);
  drawOverlapTable(cons);
  buildWhyBox(data, res, cons);

  // store
  LAST_COMPUTE = {data, res, cons, smoothed};
  renderInspector();

  const dt = (nowMs() - t0);
  // small hint if validation errors exist
  if(errs.length) toast("Computed (with validation warnings).", "warn");
  else toast("Computed (" + dt.toFixed(0) + " ms).", "ok");
}

/** ---------------------------
 *  Boot
 *  --------------------------- */
window.addEventListener("load", ()=>{
  $("#smoothLabel").textContent = $("#smoothRounds").value;
  setStateFromPreset("basic");
});
</script>
</body>
</html>
