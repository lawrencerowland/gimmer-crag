<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Fibration‑Based Milestone Linking: Toy Example</title>
  <link rel="stylesheet" href="../../common.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.5;
      margin: 20px;
      color: #2d4263;
      background-color: #fafafa;
    }
    h1, h2, h3 {
      color: #263859;
      margin-bottom: 0.5em;
    }
    #chart {
      width: 100%;
      height: 480px;
      margin-top: 20px;
      position: relative;
    }
    svg {
      width: 100%;
      height: 100%;
    }
    .node circle {
      fill: #91a8d0;
      stroke: #2d4263;
      stroke-width: 1.5px;
      transition: fill 0.2s ease;
    }
    .node text {
      font-size: 12px;
      text-anchor: middle;
      pointer-events: none;
      fill: #263859;
    }
    .link {
      fill: none;
      stroke: #c5d9e8;
      stroke-width: 1.2px;
    }
    .highlight circle {
      fill: #ffd2d2;
      stroke: #e53935;
    }
    #info {
      margin-top: 20px;
      padding: 12px;
      border: 1px solid #c5d9e8;
      background-color: #f4f7fb;
      border-radius: 4px;
      color: #263859;
    }
    #info ul {
      margin: 0;
      padding-left: 20px;
    }
    #info li {
      margin-bottom: 4px;
    }
    .updateBtn {
      margin-top: 10px;
      padding: 6px 12px;
      background-color: #4e7ac7;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .updateBtn:hover {
      background-color: #3a5a91;
    }
    footer {
      margin-top: 40px;
      font-size: 12px;
      color: #555;
    }
    footer ol {
      padding-left: 20px;
    }
    footer li {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <a href="../../index.html">Back to app index</a>
  <h1>Fibration‑Based Milestone Linking</h1>
  <p>
    In category‑theoretic project planning, one models the structure of a programme as a functor whose fibres encode local constraints and tasks. A Grothendieck fibration is such a functor whose fibres depend contravariantly in a pseudofunctorial way on arrows in the base category; it admits cartesian liftings of morphisms, so that every change in the base has a uniquely determined lift in the total category. By organising project milestones as fibres of a fibration, refinements to a sub‑plan can be lifted or pulled back through the overarching plan, ensuring that changes propagate coherently and tasks are never orphaned. Below we work through a toy example of a global marketing campaign to illustrate how such a fibration‑based model can tame interdependent milestones.
  </p>

  <h2>Fibrations and Project Planning</h2>
  <p>
    Abstractly, a fibration is a functor \(p\colon E \to B\) for which each morphism in the base category \(B\) has a so‑called cartesian lifting: given an object in the fibre over \(b\) and a morphism \(f : b' \to b\) in \(B\), there is a unique arrow in \(E\) mapping to \(f\) that pulls back the object. This encodes the idea that local data above \(b\) restrict to local data above \(b'\) in a way compatible with composition. In more concrete terms, the fibre over an output of a non‑invertible function—say, the set of even numbers mapping to \(\mathrm{True}\) under a parity test—collects all inputs consistent with that output; replacing sets by categories and functions by functors yields Grothendieck’s fibre‑wise view. The concept originated to formalise pull‑back operations on geometric objects such as vector bundles and sheaves, but it now appears throughout type theory and applied category theory.
  </p>

  <h2>Toy Example: Global Marketing Campaign</h2>
  <p>
    Imagine a global marketing campaign with three regional sub‑plans—Asia, Europe and North America. Each regional plan consists of a bundle of tasks (market research, localization, regulatory review, etc.) and constraints (such as consumer‑data regulations). We model the overarching campaign as the base category and each regional plan as a fibre category above its corresponding object. Morphisms in the base represent resource‑state transitions or high‑level dependencies, while cartesian liftings specify how tasks in one region restrict or lift along those dependencies. An update to a local constraint (e.g., new consumer data regulations in Asia) therefore induces a cartesian morphism that “lifts” the change to the global strategy and “pulls back” appropriate adjustments in other regions. The interactive diagram below visualises this structure.
  </p>

  <div id="chart"></div>
  <div id="info">Click on a regional node to display its tasks and constraints.</div>

  <h2>Discussion and Evaluation</h2>
  <p>
    The fibration‑based structure makes explicit how regional tasks depend on and contribute to the global strategy. In our toy example, Asia’s localisation task depends on market research, and its launch event depends on successful localisation; these dependencies correspond to arrows in the fibre. When a regulatory change arrives, we enact a cartesian lifting that updates Asia’s constraints and automatically flags related tasks in Europe and North America. By tracking such liftings systematically, one can audit how changes propagate, avoiding the “transition friction” of ad‑hoc spreadsheets or siloed charts. Of course, this idealised model presumes that dependencies are static and that cartesian liftings exist; in practice, cross‑regional coupling may be looser, and the pseudo‑functorial nature of real projects demands judgement about which changes should propagate. Nevertheless, the categorical viewpoint encourages planners to articulate dependencies explicitly and to design systems that propagate updates coherently.
  </p>

  <h2>Try It Yourself</h2>
  <p>
    In the interactive diagram you can click on a region (Asia, Europe or North America) to view its tasks and constraints. For Asia there is an additional button to simulate a new consumer‑data regulation. Clicking this button highlights the tasks in Europe and North America that must be revisited because they depend on the global regulatory landscape. This simple demonstration shows how a fibration‑based model can keep regional plans in sync.
  </p>

  <footer>
    <p><strong>Footnotes</strong></p>
    <ol>
      <li id="fn1">A Grothendieck fibration is a functor whose fibres depend contravariantly on base arrows and behaves pseudofunctorially.</li>
      <li id="fn2">For each base arrow there is a unique cartesian lifting, and a collection of such liftings (a cleavage) characterises the fibration.</li>
      <li id="fn3">The intuition behind fibres generalises non‑invertible functions: the fibre over True in a parity test is the set of even numbers, and this idea extends to functors and categories.</li>
      <li id="fn4">Fibred categories formalise pull‑back operations on geometric objects such as vector bundles and sheaves and underlie descent theory.</li>
    </ol>
  </footer>

  <script>
    // Use D3 from CDN for simplicity. The CDN loads asynchronously; the graph will render when the script runs.
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js';
    script.onload = drawGraph;
    document.head.appendChild(script);

    function drawGraph() {
      // Define the nodes and their positions. Regional and task nodes include metadata
      const nodes = [
        { id: 'global', name: 'Global Campaign', x: 400, y: 40, type: 'global' },
        { id: 'asia', name: 'Asia Plan', x: 200, y: 140, type: 'region' },
        { id: 'europe', name: 'Europe Plan', x: 400, y: 140, type: 'region' },
        { id: 'north', name: 'North America Plan', x: 600, y: 140, type: 'region' },
        // Asia tasks
        { id: 'asia_task1', name: 'Market Research', x: 150, y: 260, parent: 'asia', type: 'task' },
        { id: 'asia_task2', name: 'Localization', x: 200, y: 260, parent: 'asia', type: 'task' },
        { id: 'asia_task3', name: 'Launch Event', x: 250, y: 260, parent: 'asia', type: 'task' },
        // Europe tasks
        { id: 'eu_task1', name: 'Regulatory Review', x: 350, y: 260, parent: 'europe', type: 'task' },
        { id: 'eu_task2', name: 'Brand Alignment', x: 400, y: 260, parent: 'europe', type: 'task' },
        { id: 'eu_task3', name: 'Launch Event', x: 450, y: 260, parent: 'europe', type: 'task' },
        // North America tasks
        { id: 'na_task1', name: 'Digital Audit', x: 550, y: 260, parent: 'north', type: 'task' },
        { id: 'na_task2', name: 'Content Creation', x: 600, y: 260, parent: 'north', type: 'task' },
        { id: 'na_task3', name: 'Launch Event', x: 650, y: 260, parent: 'north', type: 'task' }
      ];

      // Define the link relationships (parent -> child)
      const links = [];
      nodes.forEach(node => {
        if (node.parent) {
          const parentNode = nodes.find(n => n.id === node.parent);
          links.push({ x1: parentNode.x, y1: parentNode.y + 15, x2: node.x, y2: node.y - 15 });
        }
      });
      // Add links from global to regions
      links.push({ x1: nodes[0].x, y1: nodes[0].y + 15, x2: nodes[1].x, y2: nodes[1].y - 15 });
      links.push({ x1: nodes[0].x, y1: nodes[0].y + 15, x2: nodes[2].x, y2: nodes[2].y - 15 });
      links.push({ x1: nodes[0].x, y1: nodes[0].y + 15, x2: nodes[3].x, y2: nodes[3].y - 15 });

      // Map region metadata, including tasks, constraints, and update effects
      const regionDetails = {
        asia: {
          name: 'Asia Plan',
          constraints: 'Consumer‑data regulations; language adaptation.',
          tasks: [
            { name: 'Market Research', dependencies: [] },
            { name: 'Localization', dependencies: [] },
            { name: 'Launch Event', dependencies: ['Localization'] }
          ],
          updateEffects: {
            europe: ['eu_task1', 'eu_task2'],
            north: ['na_task1', 'na_task2']
          },
          updateDescription: 'New consumer‑data regulation applied to Asia'
        },
        europe: {
          name: 'Europe Plan',
          constraints: 'GDPR compliance; cross‑market synergy.',
          tasks: [
            { name: 'Regulatory Review', dependencies: [] },
            { name: 'Brand Alignment', dependencies: [] },
            { name: 'Launch Event', dependencies: ['Regulatory Review'] }
          ],
          updateEffects: {},
          updateDescription: ''
        },
        north: {
          name: 'North America Plan',
          constraints: 'FTC guidelines; digital marketing synergy.',
          tasks: [
            { name: 'Digital Audit', dependencies: [] },
            { name: 'Content Creation', dependencies: [] },
            { name: 'Launch Event', dependencies: ['Content Creation'] }
          ],
          updateEffects: {},
          updateDescription: ''
        }
      };

      // Create SVG
      const svg = d3.select('#chart').append('svg');

      // Draw links
      svg.selectAll('line')
        .data(links)
        .enter()
        .append('line')
        .attr('class', 'link')
        .attr('x1', d => d.x1)
        .attr('y1', d => d.y1)
        .attr('x2', d => d.x2)
        .attr('y2', d => d.y2);

      // Draw nodes (groups to capture circle and text)
      const nodeGroups = svg.selectAll('g.node')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.x},${d.y})`);

      nodeGroups.append('circle')
        .attr('r', 15);

      nodeGroups.append('text')
        .attr('dy', 4)
        .text(d => (d.name.length > 12 ? `${d.name.slice(0, 10)}…` : d.name));

      // Click handler for region nodes
      nodeGroups.on('click', function(event, d) {
        // Only regions respond to clicks
        if (d.type !== 'region') return;
        displayRegionInfo(d.id);
      });

      // Helper to display region info and show update button if applicable
      function displayRegionInfo(regionId) {
        const detail = regionDetails[regionId];
        let html = `<h3>${detail.name}</h3>`;
        html += `<p><strong>Constraints:</strong> ${detail.constraints}</p>`;
        html += '<p><strong>Tasks:</strong></p><ul>';
        detail.tasks.forEach(task => {
          html += `<li>${task.name}`;
          if (task.dependencies.length > 0) {
            html += ` (depends on ${task.dependencies.join(', ')})`;
          }
          html += '</li>';
        });
        html += '</ul>';
        // Add update button for Asia only (simulate regulatory change)
        if (detail.updateDescription) {
          html += `<button class="updateBtn" onclick="applyUpdate('${regionId}')">${detail.updateDescription}</button>`;
        }
        document.getElementById('info').innerHTML = html;
      }

      // Make applyUpdate globally accessible so that inline onclick can call it
      window.applyUpdate = function(regionId) {
        const detail = regionDetails[regionId];
        // Reset all task nodes
        nodeGroups.classed('highlight', false);
        // Highlight tasks in the affected regions
        Object.entries(detail.updateEffects).forEach(([targetRegion, taskIds]) => {
          taskIds.forEach(taskId => {
            svg.selectAll('g.node')
              .filter(d => d.id === taskId)
              .classed('highlight', true);
          });
        });
        // Informational message
        let msg = `<h3>${detail.name}</h3>`;
        msg += `<p><strong>Update:</strong> ${detail.updateDescription}.</p>`;
        msg += '<p>The following tasks in other regions are flagged for review:</p><ul>';
        Object.entries(detail.updateEffects).forEach(([region, taskIds]) => {
          msg += `<li><strong>${regionDetails[region].name}</strong>: `;
          msg += taskIds.map(id => nodes.find(n => n.id === id).name).join(', ');
          msg += '</li>';
        });
        msg += '</ul>';
        document.getElementById('info').innerHTML = msg;
      };
    }
  </script>
</body>
</html>
